"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-activity-calendar";
exports.ids = ["vendor-chunks/react-activity-calendar"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-activity-calendar/build/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-activity-calendar/build/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar dateFns = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/index.js\");\nvar jsxRuntime = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\nconst NAMESPACE = \"react-activity-calendar\";\nconst LABEL_MARGIN = 8; // px\nconst DEFAULT_MONTH_LABELS = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n];\nconst DEFAULT_LABELS = {\n    months: DEFAULT_MONTH_LABELS,\n    weekdays: [\n        \"Sun\",\n        \"Mon\",\n        \"Tue\",\n        \"Wed\",\n        \"Thu\",\n        \"Fri\",\n        \"Sat\"\n    ],\n    totalCount: \"{{count}} activities in {{year}}\",\n    legend: {\n        less: \"Less\",\n        more: \"More\"\n    }\n};\nfunction useColorScheme() {\n    const [colorScheme, setColorScheme] = react.useState(\"light\");\n    const onChange = (event)=>{\n        setColorScheme(event.matches ? \"dark\" : \"light\");\n    };\n    react.useEffect(()=>{\n        const mediaQuery = window.matchMedia(\"(prefers-color-scheme: dark)\");\n        // eslint-disable-next-line react-hooks/set-state-in-effect\n        setColorScheme(mediaQuery.matches ? \"dark\" : \"light\");\n        mediaQuery.addEventListener(\"change\", onChange);\n        return ()=>{\n            mediaQuery.removeEventListener(\"change\", onChange);\n        };\n    }, []);\n    return colorScheme;\n}\nconst loadingAnimationName = `${NAMESPACE}--loading-animation`;\nfunction useLoadingAnimation(zeroColor, colorScheme) {\n    react.useEffect(()=>{\n        const colorLoading = `oklab(from ${zeroColor} l a b)`;\n        const colorActive = colorScheme === \"light\" ? `oklab(from ${zeroColor} calc(l * 0.96) a b)` : `oklab(from ${zeroColor} calc(l * 1.08) a b)`;\n        const style = document.createElement(\"style\");\n        style.innerHTML = `\n      @keyframes ${loadingAnimationName} {\n        0% {\n          fill: ${colorLoading};\n        }\n        50% {\n          fill: ${colorActive};\n        }\n        100% {\n          fill: ${colorLoading};\n        }\n      }\n    `;\n        document.head.appendChild(style);\n        return ()=>{\n            document.head.removeChild(style);\n        };\n    }, [\n        zeroColor,\n        colorScheme\n    ]);\n}\nconst query = \"(prefers-reduced-motion: reduce)\";\nfunction usePrefersReducedMotion() {\n    const [prefersReducedMotion, setPrefersReducedMotion] = react.useState(true);\n    react.useEffect(()=>{\n        const mediaQuery = window.matchMedia(query);\n        // eslint-disable-next-line react-hooks/set-state-in-effect\n        setPrefersReducedMotion(mediaQuery.matches);\n        const onChange = (event)=>{\n            setPrefersReducedMotion(event.matches);\n        };\n        mediaQuery.addEventListener(\"change\", onChange);\n        return ()=>{\n            mediaQuery.removeEventListener(\"change\", onChange);\n        };\n    }, []);\n    return prefersReducedMotion;\n}\nfunction validateActivities(activities, maxLevel) {\n    if (activities.length === 0) {\n        throw new Error(\"Activity data must not be empty.\");\n    }\n    for (const { date, level, count } of activities){\n        if (!dateFns.isValid(dateFns.parseISO(date))) {\n            throw new Error(`Activity date '${date}' is not a valid ISO 8601 date string.`);\n        }\n        if (count < 0) {\n            throw new RangeError(`Activity count must not be negative, found ${count}.`);\n        }\n        if (level < 0 || level > maxLevel) {\n            throw new RangeError(`Activity level ${level} for ${date} is out of range. It must be between 0 and ${maxLevel}.`);\n        }\n    }\n}\nfunction groupByWeeks(activities, weekStart = 0 // 0 = Sunday\n) {\n    const normalizedActivities = fillHoles(activities);\n    // Determine the first date of the calendar. If the first date is not the\n    // passed weekday, the respective weekday one week earlier is used.\n    const firstActivity = normalizedActivities[0];\n    const firstDate = dateFns.parseISO(firstActivity.date);\n    const firstCalendarDate = dateFns.getDay(firstDate) === weekStart ? firstDate : dateFns.subWeeks(dateFns.nextDay(firstDate, weekStart), 1);\n    // To correctly group activities by week, it is necessary to left-pad the list\n    // because the first date might not be set start weekday.\n    const paddedActivities = [\n        ...Array(dateFns.differenceInCalendarDays(firstDate, firstCalendarDate)).fill(undefined),\n        ...normalizedActivities\n    ];\n    const numberOfWeeks = Math.ceil(paddedActivities.length / 7);\n    // Finally, group activities by week\n    return range(numberOfWeeks).map((weekIndex)=>paddedActivities.slice(weekIndex * 7, weekIndex * 7 + 7));\n}\n/**\n * The calendar expects a continuous sequence of days,\n * so fill gaps with empty activity data.\n */ function fillHoles(activities) {\n    const calendar = new Map(activities.map((a)=>[\n            a.date,\n            a\n        ]));\n    const firstActivity = activities[0];\n    const lastActivity = activities[activities.length - 1];\n    return dateFns.eachDayOfInterval({\n        start: dateFns.parseISO(firstActivity.date),\n        end: dateFns.parseISO(lastActivity.date)\n    }).map((day)=>{\n        const date = dateFns.formatISO(day, {\n            representation: \"date\"\n        });\n        if (calendar.has(date)) {\n            return calendar.get(date);\n        }\n        return {\n            date,\n            count: 0,\n            level: 0\n        };\n    });\n}\nfunction getClassName(name) {\n    return `${NAMESPACE}__${name}`;\n}\nfunction generateEmptyData() {\n    const year = new Date().getFullYear();\n    const days = dateFns.eachDayOfInterval({\n        start: new Date(year, 0, 1),\n        end: new Date(year, 11, 31)\n    });\n    return days.map((date)=>({\n            date: dateFns.formatISO(date, {\n                representation: \"date\"\n            }),\n            count: 0,\n            level: 0\n        }));\n}\nfunction range(n) {\n    return [\n        ...Array(n).keys()\n    ];\n}\nfunction getMonthLabels(weeks, monthNames = DEFAULT_MONTH_LABELS) {\n    return weeks.reduce((labels, week, weekIndex)=>{\n        const firstActivity = week.find((activity)=>activity !== undefined);\n        if (!firstActivity) {\n            throw new Error(`Unexpected error: Week ${weekIndex + 1} is empty.`);\n        }\n        const month = monthNames[dateFns.getMonth(dateFns.parseISO(firstActivity.date))];\n        if (!month) {\n            const monthName = new Date(firstActivity.date).toLocaleString(\"en-US\", {\n                month: \"short\"\n            });\n            throw new Error(`Unexpected error: undefined month label for ${monthName}.`);\n        }\n        const prevLabel = labels[labels.length - 1];\n        if (weekIndex === 0 || !prevLabel || prevLabel.label !== month) {\n            return [\n                ...labels,\n                {\n                    weekIndex,\n                    label: month\n                }\n            ];\n        }\n        return labels;\n    }, []).filter(({ weekIndex }, index, labels)=>{\n        // Labels should only be shown if there is \"enough\" space (data).\n        // This is a naive implementation that does not take the block size,\n        // font size, etc. into account.\n        const minWeeks = 3;\n        // Skip the first month label if there is not enough space to the next one.\n        if (index === 0) {\n            return labels[1] && labels[1].weekIndex - weekIndex >= minWeeks;\n        }\n        // Skip the last month label if there is not enough data in that month\n        // to avoid overflowing the calendar on the right.\n        if (index === labels.length - 1) {\n            return weeks.slice(weekIndex).length >= minWeeks;\n        }\n        return true;\n    });\n}\nfunction maxWeekdayLabelWidth(labels, showWeekdayLabel, fontSize) {\n    if (labels.length !== 7) {\n        throw new Error(\"Exactly 7 labels, one for each weekday must be passed.\");\n    }\n    return labels.reduce((maxWidth, label, index)=>showWeekdayLabel.byDayIndex(index) ? Math.max(maxWidth, Math.ceil(calcTextDimensions(label, fontSize).width)) : maxWidth, 0);\n}\nfunction calcTextDimensions(text, fontSize) {\n    if (typeof document === \"undefined\" || \"undefined\" === \"undefined\") {\n        return {\n            width: 0,\n            height: 0\n        };\n    }\n    if (fontSize < 1) {\n        throw new RangeError(\"fontSize must be positive\");\n    }\n    if (text.length === 0) {\n        return {\n            width: 0,\n            height: 0\n        };\n    }\n    const namespace = \"http://www.w3.org/2000/svg\";\n    const svg = document.createElementNS(namespace, \"svg\");\n    svg.style.position = \"absolute\";\n    svg.style.visibility = \"hidden\";\n    svg.style.fontFamily = window.getComputedStyle(document.body).fontFamily;\n    svg.style.fontSize = `${fontSize}px`;\n    const textNode = document.createElementNS(namespace, \"text\");\n    textNode.textContent = text;\n    svg.appendChild(textNode);\n    document.body.appendChild(svg);\n    const boundingBox = textNode.getBBox();\n    document.body.removeChild(svg);\n    return {\n        width: boundingBox.width,\n        height: boundingBox.height\n    };\n}\nfunction initWeekdayLabels(input, weekStart) {\n    if (!input) return {\n        byDayIndex: ()=>false,\n        shouldShow: false\n    };\n    // Default: Show every second day of the week.\n    if (input === true) {\n        return {\n            byDayIndex: (index)=>{\n                return (7 + index - weekStart) % 7 % 2 !== 0;\n            },\n            shouldShow: true\n        };\n    }\n    const indexed = [];\n    for (const name of input){\n        const index = dayNameToIndex[name.toLowerCase()];\n        indexed[index] = true;\n    }\n    return {\n        byDayIndex: (index)=>indexed[index] ?? false,\n        shouldShow: input.length > 0\n    };\n}\nconst dayNameToIndex = {\n    sun: 0,\n    mon: 1,\n    tue: 2,\n    wed: 3,\n    thu: 4,\n    fri: 5,\n    sat: 6\n};\nfunction createTheme(input, steps = 5) {\n    const defaultTheme = createDefaultTheme(steps);\n    if (input) {\n        validateThemeInput(input, steps);\n        input.light = input.light ?? defaultTheme.light;\n        input.dark = input.dark ?? defaultTheme.dark;\n        return {\n            light: isPair(input.light) ? calcColorScale(input.light, steps) : input.light,\n            dark: isPair(input.dark) ? calcColorScale(input.dark, steps) : input.dark\n        };\n    }\n    return defaultTheme;\n}\nfunction createDefaultTheme(steps) {\n    return {\n        light: calcColorScale([\n            \"hsl(0, 0%, 92%)\",\n            \"hsl(0, 0%, 26%)\"\n        ], steps),\n        dark: calcColorScale([\n            \"hsl(0, 0%, 22%)\",\n            \"hsl(0, 0%, 92%)\"\n        ], steps)\n    };\n}\nfunction validateThemeInput(input, steps) {\n    const maxLevelHint = 'The number of colors is controlled by the \"maxLevel\" property.';\n    if (typeof input !== \"object\" || input.light === undefined && input.dark === undefined) {\n        throw new Error(`The theme object must contain at least one of the fields \"light\" and \"dark\" with exactly 2 or ${steps} colors respectively. ${maxLevelHint}`);\n    }\n    if (input.light) {\n        const { length } = input.light;\n        if (length !== 2 && length !== steps) {\n            throw new Error(`theme.light must contain exactly 2 or ${steps} colors, ${length} passed. ${maxLevelHint}`);\n        }\n        for (const c of input.light){\n            if (false) {}\n        }\n    }\n    if (input.dark) {\n        const { length } = input.dark;\n        if (length !== 2 && length !== steps) {\n            throw new Error(`theme.dark must contain exactly 2 or ${steps} colors, ${length} passed. ${maxLevelHint}`);\n        }\n        for (const c of input.dark){\n            if (false) {}\n        }\n    }\n}\nfunction calcColorScale([start, end], steps) {\n    return range(steps).map((i)=>{\n        // In the loading animation the zero color is used.\n        // However, Safari 16 crashes if a CSS color-mix expression like below is\n        // combined with relative color syntax to calculate a hue variation for the\n        // animation. Since the start and end colors do not need to be mixed, they\n        // can be returned directly to work around this issue.\n        switch(i){\n            case 0:\n                return start;\n            case steps - 1:\n                return end;\n            default:\n                {\n                    const pos = i / (steps - 1) * 100;\n                    return `color-mix(in oklab, ${end} ${parseFloat(pos.toFixed(2))}%, ${start})`;\n                }\n        }\n    });\n}\nfunction isPair(val) {\n    return val.length === 2;\n}\nconst styles = {\n    container: (fontSize)=>({\n            width: \"max-content\",\n            // Calendar should not grow\n            maxWidth: \"100%\",\n            // Do not remove - parent might be a flexbox\n            display: \"flex\",\n            flexDirection: \"column\",\n            gap: \"8px\",\n            fontSize: `${fontSize}px`\n        }),\n    scrollContainer: (fontSize)=>({\n            maxWidth: \"100%\",\n            overflowX: \"auto\",\n            overflowY: \"hidden\",\n            paddingTop: Math.ceil(0.1 * fontSize) // SVG <text> overflows in Firefox at y=0\n        }),\n    calendar: {\n        display: \"block\",\n        // SVGs are inline-block by default\n        overflow: \"visible\" // Weekday labels are rendered left of the container\n    },\n    rect: (colorScheme)=>({\n            stroke: colorScheme === \"light\" ? \"rgba(0, 0, 0, 0.08)\" : \"rgba(255, 255, 255, 0.04)\"\n        }),\n    footer: {\n        container: {\n            display: \"flex\",\n            flexWrap: \"wrap\",\n            gap: \"4px 16px\",\n            whiteSpace: \"nowrap\"\n        },\n        legend: {\n            marginLeft: \"auto\",\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: \"3px\"\n        }\n    }\n};\nconst ActivityCalendar = /*#__PURE__*/ react.forwardRef(({ data: activities, blockMargin = 4, blockRadius = 2, blockSize = 12, colorScheme: colorSchemeProp = undefined, eventHandlers = {}, fontSize = 14, hideColorLegend = false, hideMonthLabels = false, hideTotalCount = false, labels: labelsProp = undefined, maxLevel = 4, loading = false, renderBlock = undefined, renderColorLegend = undefined, showWeekdayLabels = false, style: styleProp = {}, theme: themeProp = undefined, totalCount: totalCountProp = undefined, weekStart = 0 // Sunday\n }, // Required for react-docgen\nref)=>{\n    const [isClient, setIsClient] = react.useState(false);\n    react.useEffect(()=>{\n        setIsClient(true);\n    }, []);\n    maxLevel = Math.max(1, maxLevel);\n    const theme = createTheme(themeProp, maxLevel + 1);\n    const systemColorScheme = useColorScheme();\n    const colorScheme = colorSchemeProp ?? systemColorScheme;\n    const colorScale = theme[colorScheme];\n    useLoadingAnimation(colorScale[0], colorScheme);\n    const useAnimation = !usePrefersReducedMotion();\n    if (loading) {\n        activities = generateEmptyData();\n    }\n    validateActivities(activities, maxLevel);\n    const firstActivity = activities[0];\n    const year = dateFns.getYear(dateFns.parseISO(firstActivity.date));\n    const weeks = groupByWeeks(activities, weekStart);\n    const labels = Object.assign({}, DEFAULT_LABELS, labelsProp);\n    const labelHeight = hideMonthLabels ? 0 : fontSize + LABEL_MARGIN;\n    const weekdayLabels = initWeekdayLabels(showWeekdayLabels, weekStart);\n    // Must be calculated on the client or SSR hydration errors will occur\n    // because server and client HTML would not match.\n    const weekdayLabelOffset = isClient && weekdayLabels.shouldShow ? maxWeekdayLabelWidth(labels.weekdays, weekdayLabels, fontSize) + LABEL_MARGIN : undefined;\n    function getDimensions() {\n        return {\n            width: weeks.length * (blockSize + blockMargin) - blockMargin,\n            height: labelHeight + (blockSize + blockMargin) * 7 - blockMargin\n        };\n    }\n    function getEventHandlers(activity) {\n        return Object.keys(eventHandlers).reduce((handlers, key)=>({\n                ...handlers,\n                [key]: (event)=>eventHandlers[key]?.(event)(activity)\n            }), {});\n    }\n    function renderCalendar() {\n        return weeks.map((week, weekIndex)=>week.map((activity, dayIndex)=>{\n                if (!activity) {\n                    return null;\n                }\n                const loadingAnimation = loading && useAnimation ? {\n                    animation: `${loadingAnimationName} 1.75s ease-in-out infinite`,\n                    animationDelay: `${weekIndex * 20 + dayIndex * 20}ms`\n                } : undefined;\n                const block = /*#__PURE__*/ jsxRuntime.jsx(\"rect\", {\n                    ...getEventHandlers(activity),\n                    x: 0,\n                    y: labelHeight + (blockSize + blockMargin) * dayIndex,\n                    width: blockSize,\n                    height: blockSize,\n                    rx: blockRadius,\n                    ry: blockRadius,\n                    fill: colorScale[activity.level],\n                    \"data-date\": activity.date,\n                    \"data-level\": activity.level,\n                    style: {\n                        ...styles.rect(colorScheme),\n                        ...loadingAnimation\n                    }\n                });\n                return /*#__PURE__*/ jsxRuntime.jsx(react.Fragment, {\n                    children: renderBlock ? renderBlock(block, activity) : block\n                }, activity.date);\n            })).map((week, x)=>/*#__PURE__*/ jsxRuntime.jsx(\"g\", {\n                transform: `translate(${(blockSize + blockMargin) * x}, 0)`,\n                children: week\n            }, x));\n    }\n    function renderFooter() {\n        if (hideTotalCount && hideColorLegend) {\n            return null;\n        }\n        const totalCount = typeof totalCountProp === \"number\" ? totalCountProp : activities.reduce((sum, activity)=>sum + activity.count, 0);\n        return /*#__PURE__*/ jsxRuntime.jsxs(\"footer\", {\n            className: getClassName(\"footer\"),\n            style: {\n                ...styles.footer.container,\n                marginLeft: weekdayLabelOffset\n            },\n            children: [\n                loading && /*#__PURE__*/ jsxRuntime.jsx(\"div\", {\n                    children: \"\\xa0\"\n                }),\n                !loading && !hideTotalCount && /*#__PURE__*/ jsxRuntime.jsx(\"div\", {\n                    className: getClassName(\"count\"),\n                    children: labels.totalCount ? labels.totalCount.replace(\"{{count}}\", String(totalCount)).replace(\"{{year}}\", String(year)) : `${totalCount} activities in ${year}`\n                }),\n                !loading && !hideColorLegend && /*#__PURE__*/ jsxRuntime.jsxs(\"div\", {\n                    className: getClassName(\"legend-colors\"),\n                    style: styles.footer.legend,\n                    children: [\n                        /*#__PURE__*/ jsxRuntime.jsx(\"span\", {\n                            style: {\n                                marginRight: \"0.4em\"\n                            },\n                            children: labels.legend.less\n                        }),\n                        range(maxLevel + 1).map((level)=>{\n                            const block = /*#__PURE__*/ jsxRuntime.jsx(\"svg\", {\n                                width: blockSize,\n                                height: blockSize,\n                                children: /*#__PURE__*/ jsxRuntime.jsx(\"rect\", {\n                                    width: blockSize,\n                                    height: blockSize,\n                                    fill: colorScale[level],\n                                    rx: blockRadius,\n                                    ry: blockRadius,\n                                    style: styles.rect(colorScheme)\n                                })\n                            });\n                            return /*#__PURE__*/ jsxRuntime.jsx(react.Fragment, {\n                                children: renderColorLegend ? renderColorLegend(block, level) : block\n                            }, level);\n                        }),\n                        /*#__PURE__*/ jsxRuntime.jsx(\"span\", {\n                            style: {\n                                marginLeft: \"0.4em\"\n                            },\n                            children: labels.legend.more\n                        })\n                    ]\n                })\n            ]\n        });\n    }\n    function renderWeekdayLabels() {\n        if (!weekdayLabels.shouldShow) {\n            return null;\n        }\n        return /*#__PURE__*/ jsxRuntime.jsx(\"g\", {\n            className: getClassName(\"legend-weekday\"),\n            children: range(7).map((index)=>{\n                const dayIndex = (index + weekStart) % 7;\n                if (!weekdayLabels.byDayIndex(dayIndex)) {\n                    return null;\n                }\n                return /*#__PURE__*/ jsxRuntime.jsx(\"text\", {\n                    x: -LABEL_MARGIN,\n                    y: labelHeight + (blockSize + blockMargin) * index + blockSize / 2,\n                    dominantBaseline: \"central\",\n                    textAnchor: \"end\",\n                    fill: \"currentColor\",\n                    children: labels.weekdays[dayIndex]\n                }, index);\n            })\n        });\n    }\n    function renderMonthLabels() {\n        if (hideMonthLabels) {\n            return null;\n        }\n        return /*#__PURE__*/ jsxRuntime.jsx(\"g\", {\n            className: getClassName(\"legend-month\"),\n            children: getMonthLabels(weeks, labels.months).map(({ label, weekIndex })=>/*#__PURE__*/ jsxRuntime.jsx(\"text\", {\n                    x: (blockSize + blockMargin) * weekIndex,\n                    y: 0,\n                    dominantBaseline: \"hanging\",\n                    fill: \"currentColor\",\n                    children: label\n                }, weekIndex))\n        });\n    }\n    const { width, height } = getDimensions();\n    return /*#__PURE__*/ jsxRuntime.jsxs(\"article\", {\n        ref: ref,\n        className: NAMESPACE,\n        style: {\n            ...styleProp,\n            ...styles.container(fontSize)\n        },\n        children: [\n            /*#__PURE__*/ jsxRuntime.jsx(\"div\", {\n                className: getClassName(\"scroll-container\"),\n                style: styles.scrollContainer(fontSize),\n                children: /*#__PURE__*/ jsxRuntime.jsxs(\"svg\", {\n                    width: width,\n                    height: height,\n                    viewBox: `0 0 ${width} ${height}`,\n                    className: getClassName(\"calendar\"),\n                    style: {\n                        ...styles.calendar,\n                        marginLeft: weekdayLabelOffset\n                    },\n                    children: [\n                        !loading && renderWeekdayLabels(),\n                        !loading && renderMonthLabels(),\n                        renderCalendar()\n                    ]\n                })\n            }),\n            renderFooter()\n        ]\n    });\n});\nActivityCalendar.displayName = \"ActivityCalendar\";\nconst Skeleton = (props)=>/*#__PURE__*/ jsxRuntime.jsx(ActivityCalendar, {\n        data: [],\n        ...props\n    });\nexports.ActivityCalendar = ActivityCalendar;\nexports.Skeleton = Skeleton;\nexports[\"default\"] = ActivityCalendar; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtYWN0aXZpdHktY2FsZW5kYXIvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFPLE1BQU1BLFlBQVk7QUFDbEIsTUFBTUMsZUFBZSxHQUFDO0FBRXRCLE1BQU1DLHVCQUF1QjtJQUNsQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVNLE1BQU1DLGlCQUFpQjtJQUM1QkMsUUFBUUY7SUFDUkcsVUFBVTtRQUFDO1FBQU87UUFBTztRQUFPO1FBQU87UUFBTztRQUFPO0tBQU07SUFDM0RDLFlBQVk7SUFDWkMsUUFBUTtRQUNOQyxNQUFNO1FBQ05DLE1BQU07SUFDUjtBQUNGO0FDeEJPLFNBQVNDO0lBQ2QsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdDLE1BQUFBLFFBQVEsQ0FBbUI7SUFFakUsTUFBTUMsV0FBWUMsQ0FBQUE7UUFDaEJILGVBQWVHLE1BQU1DLE9BQU8sR0FBRyxTQUFTO0lBQzFDO0lBRUFDLE1BQUFBLFNBQVMsQ0FBQztRQUNSLE1BQU1DLGFBQWFDLE9BQU9DLFVBQVUsQ0FBQztRQUVyQztRQUNBUixlQUFlTSxXQUFXRixPQUFPLEdBQUcsU0FBUztRQUU3Q0UsV0FBV0csZ0JBQWdCLENBQUMsVUFBVVA7UUFFdEMsT0FBTztZQUNMSSxXQUFXSSxtQkFBbUIsQ0FBQyxVQUFVUjtRQUMzQztJQUNGLEdBQUcsRUFBRTtJQUVMLE9BQU9IO0FBQ1Q7QUNwQk8sTUFBTVksdUJBQXVCLEdBQUd2QixVQUFTLG9CQUFxQjtBQUU5RCxTQUFTd0Isb0JBQW9CQyxTQUFpQixFQUFFZCxXQUE2QjtJQUNsRk0sTUFBQUEsU0FBUyxDQUFDO1FBQ1IsTUFBTVMsZUFBZSxjQUFjRCxVQUFTLFFBQVM7UUFDckQsTUFBTUUsY0FDSmhCLGdCQUFnQixVQUNaLGNBQWNjLFVBQVMscUJBQXNCLEdBQzdDLGNBQWNBLFVBQVMscUJBQXNCO1FBRW5E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b0JBQWNxSyxVQUdsQjFIO2dCQUFLLEdBRkRwQztRQUlQO0lBR1I7SUFFQSxNQUFNLEVBQUUrQyxLQUFLLEVBQUVFLE1BQUFBLEVBQVEsR0FBRzZGO0lBRTFCLHFCQUNFb0IsV0FBQUEsSUFBQTtRQUNFaEMsS0FBS0E7UUFDTGlDLFdBQVd6TztRQUNYNEIsT0FBTztZQUFFLEdBQUd3SyxTQUFTO1lBQUUsR0FBR2pDLE9BQU9DLFNBQVMsQ0FBQ3BELFNBQVE7O1FBQUlvSCxVQUFBO1lBQUEsY0FFdkROLFdBQUFBLEdBQUE7Z0JBQUtXLFdBQVdySixhQUFhO2dCQUFxQnhELE9BQU91SSxPQUFPSyxlQUFlLENBQUN4RDtnQkFBVW9ILFVBQUEsY0FDeEZJLFdBQUFBLElBQUE7b0JBQ0VuSCxPQUFPQTtvQkFDUEUsUUFBUUE7b0JBQ1IwSCxTQUFTLE9BQU81SCxNQUFLLEdBQUlFLE9BQU0sQ0FBRztvQkFDbENrSCxXQUFXckosYUFBYTtvQkFDeEJ4RCxPQUFPO3dCQUFFLEdBQUd1SSxPQUFPM0YsUUFBUTt3QkFBRTBHLFlBQVlpQzs7b0JBQXFCaUIsVUFBQTt3QkFFN0QsQ0FBQ3BDLFdBQVc2Qzt3QkFDWixDQUFDN0MsV0FBV2dEO3dCQUNaeEI7cUJBQWdCOztZQUNiO1lBRVBjO1NBQWM7SUFBQTtBQUdyQjtBQUdGbEQsaUJBQWlCOEQsV0FBVyxHQUFHO01BRWxCQyxXQUFZQyxDQUFBQSxRQUEwQixjQUFLdEIsV0FBQUEsR0FBQSxDQUFDMUMsa0JBQWdCO1FBQUNFLE1BQU0sRUFBRztRQUFBLEdBQUs4RCxLQUFBQTtJQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLXNpdGUtMi8uLi9zcmMvY29uc3RhbnRzLnRzP2IxM2UiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLXNpdGUtMi8uLi9zcmMvaG9va3MvdXNlQ29sb3JTY2hlbWUudHM/NzljNyIsIndlYnBhY2s6Ly9wb3J0Zm9saW8tc2l0ZS0yLy4uL3NyYy9ob29rcy91c2VMb2FkaW5nQW5pbWF0aW9uLnRzP2NiNmIiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLXNpdGUtMi8uLi9zcmMvaG9va3MvdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24udHM/Nzk5YyIsIndlYnBhY2s6Ly9wb3J0Zm9saW8tc2l0ZS0yLy4uL3NyYy9saWIvY2FsZW5kYXIudHM/NmUyNSIsIndlYnBhY2s6Ly9wb3J0Zm9saW8tc2l0ZS0yLy4uL3NyYy9saWIvbGFiZWwudHM/MGE1ZSIsIndlYnBhY2s6Ly9wb3J0Zm9saW8tc2l0ZS0yLy4uL3NyYy9saWIvdGhlbWUudHM/N2QzMiIsIndlYnBhY2s6Ly9wb3J0Zm9saW8tc2l0ZS0yLy4uL3NyYy9jb21wb25lbnQvc3R5bGVzLnRzPzMyOTQiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLXNpdGUtMi8uLi9zcmMvY29tcG9uZW50L0FjdGl2aXR5Q2FsZW5kYXIudHN4PzRiODMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IE5BTUVTUEFDRSA9ICdyZWFjdC1hY3Rpdml0eS1jYWxlbmRhcidcbmV4cG9ydCBjb25zdCBMQUJFTF9NQVJHSU4gPSA4IC8vIHB4XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX01PTlRIX0xBQkVMUyA9IFtcbiAgJ0phbicsXG4gICdGZWInLFxuICAnTWFyJyxcbiAgJ0FwcicsXG4gICdNYXknLFxuICAnSnVuJyxcbiAgJ0p1bCcsXG4gICdBdWcnLFxuICAnU2VwJyxcbiAgJ09jdCcsXG4gICdOb3YnLFxuICAnRGVjJyxcbl1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTEFCRUxTID0ge1xuICBtb250aHM6IERFRkFVTFRfTU9OVEhfTEFCRUxTLFxuICB3ZWVrZGF5czogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgdG90YWxDb3VudDogJ3t7Y291bnR9fSBhY3Rpdml0aWVzIGluIHt7eWVhcn19JyxcbiAgbGVnZW5kOiB7XG4gICAgbGVzczogJ0xlc3MnLFxuICAgIG1vcmU6ICdNb3JlJyxcbiAgfSxcbn1cbiIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbG9yU2NoZW1lKCkge1xuICBjb25zdCBbY29sb3JTY2hlbWUsIHNldENvbG9yU2NoZW1lXSA9IHVzZVN0YXRlPCdsaWdodCcgfCAnZGFyayc+KCdsaWdodCcpXG5cbiAgY29uc3Qgb25DaGFuZ2UgPSAoZXZlbnQ6IE1lZGlhUXVlcnlMaXN0RXZlbnQpID0+IHtcbiAgICBzZXRDb2xvclNjaGVtZShldmVudC5tYXRjaGVzID8gJ2RhcmsnIDogJ2xpZ2h0JylcbiAgfVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbWVkaWFRdWVyeSA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJylcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9zZXQtc3RhdGUtaW4tZWZmZWN0XG4gICAgc2V0Q29sb3JTY2hlbWUobWVkaWFRdWVyeS5tYXRjaGVzID8gJ2RhcmsnIDogJ2xpZ2h0JylcblxuICAgIG1lZGlhUXVlcnkuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWVkaWFRdWVyeS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSlcbiAgICB9XG4gIH0sIFtdKVxuXG4gIHJldHVybiBjb2xvclNjaGVtZVxufVxuIiwiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOQU1FU1BBQ0UgfSBmcm9tICcuLi9jb25zdGFudHMnXG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nQW5pbWF0aW9uTmFtZSA9IGAke05BTUVTUEFDRX0tLWxvYWRpbmctYW5pbWF0aW9uYFxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9hZGluZ0FuaW1hdGlvbih6ZXJvQ29sb3I6IHN0cmluZywgY29sb3JTY2hlbWU6ICdsaWdodCcgfCAnZGFyaycpIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb2xvckxvYWRpbmcgPSBgb2tsYWIoZnJvbSAke3plcm9Db2xvcn0gbCBhIGIpYFxuICAgIGNvbnN0IGNvbG9yQWN0aXZlID1cbiAgICAgIGNvbG9yU2NoZW1lID09PSAnbGlnaHQnXG4gICAgICAgID8gYG9rbGFiKGZyb20gJHt6ZXJvQ29sb3J9IGNhbGMobCAqIDAuOTYpIGEgYilgXG4gICAgICAgIDogYG9rbGFiKGZyb20gJHt6ZXJvQ29sb3J9IGNhbGMobCAqIDEuMDgpIGEgYilgXG5cbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgICBzdHlsZS5pbm5lckhUTUwgPSBgXG4gICAgICBAa2V5ZnJhbWVzICR7bG9hZGluZ0FuaW1hdGlvbk5hbWV9IHtcbiAgICAgICAgMCUge1xuICAgICAgICAgIGZpbGw6ICR7Y29sb3JMb2FkaW5nfTtcbiAgICAgICAgfVxuICAgICAgICA1MCUge1xuICAgICAgICAgIGZpbGw6ICR7Y29sb3JBY3RpdmV9O1xuICAgICAgICB9XG4gICAgICAgIDEwMCUge1xuICAgICAgICAgIGZpbGw6ICR7Y29sb3JMb2FkaW5nfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGBcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoc3R5bGUpXG4gICAgfVxuICB9LCBbemVyb0NvbG9yLCBjb2xvclNjaGVtZV0pXG59XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5cbmNvbnN0IHF1ZXJ5ID0gJyhwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24oKSB7XG4gIGNvbnN0IFtwcmVmZXJzUmVkdWNlZE1vdGlvbiwgc2V0UHJlZmVyc1JlZHVjZWRNb3Rpb25dID0gdXNlU3RhdGUodHJ1ZSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShxdWVyeSlcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9zZXQtc3RhdGUtaW4tZWZmZWN0XG4gICAgc2V0UHJlZmVyc1JlZHVjZWRNb3Rpb24obWVkaWFRdWVyeS5tYXRjaGVzKVxuXG4gICAgY29uc3Qgb25DaGFuZ2UgPSAoZXZlbnQ6IE1lZGlhUXVlcnlMaXN0RXZlbnQpID0+IHtcbiAgICAgIHNldFByZWZlcnNSZWR1Y2VkTW90aW9uKGV2ZW50Lm1hdGNoZXMpXG4gICAgfVxuXG4gICAgbWVkaWFRdWVyeS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSlcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtZWRpYVF1ZXJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgcmV0dXJuIHByZWZlcnNSZWR1Y2VkTW90aW9uXG59XG4iLCJpbXBvcnQge1xuICBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMsXG4gIGVhY2hEYXlPZkludGVydmFsLFxuICBlbmRPZlllYXIsXG4gIGZvcm1hdElTTyxcbiAgZ2V0RGF5LFxuICBpc1ZhbGlkLFxuICBuZXh0RGF5LFxuICBwYXJzZUlTTyxcbiAgc3RhcnRPZlllYXIsXG4gIHN1YldlZWtzLFxufSBmcm9tICdkYXRlLWZucydcbmltcG9ydCB7IE5BTUVTUEFDRSB9IGZyb20gJy4uL2NvbnN0YW50cydcbmltcG9ydCB0eXBlIHsgQWN0aXZpdHksIERheUluZGV4LCBXZWVrIH0gZnJvbSAnLi4vdHlwZXMnXG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFjdGl2aXRpZXMoYWN0aXZpdGllczogQXJyYXk8QWN0aXZpdHk+LCBtYXhMZXZlbDogbnVtYmVyKSB7XG4gIGlmIChhY3Rpdml0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWN0aXZpdHkgZGF0YSBtdXN0IG5vdCBiZSBlbXB0eS4nKVxuICB9XG5cbiAgZm9yIChjb25zdCB7IGRhdGUsIGxldmVsLCBjb3VudCB9IG9mIGFjdGl2aXRpZXMpIHtcbiAgICBpZiAoIWlzVmFsaWQocGFyc2VJU08oZGF0ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdGl2aXR5IGRhdGUgJyR7ZGF0ZX0nIGlzIG5vdCBhIHZhbGlkIElTTyA4NjAxIGRhdGUgc3RyaW5nLmApXG4gICAgfVxuXG4gICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEFjdGl2aXR5IGNvdW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlLCBmb3VuZCAke2NvdW50fS5gKVxuICAgIH1cblxuICAgIGlmIChsZXZlbCA8IDAgfHwgbGV2ZWwgPiBtYXhMZXZlbCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgIGBBY3Rpdml0eSBsZXZlbCAke2xldmVsfSBmb3IgJHtkYXRlfSBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYmV0d2VlbiAwIGFuZCAke21heExldmVsfS5gLFxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBCeVdlZWtzKFxuICBhY3Rpdml0aWVzOiBBcnJheTxBY3Rpdml0eT4sXG4gIHdlZWtTdGFydDogRGF5SW5kZXggPSAwLCAvLyAwID0gU3VuZGF5XG4pOiBBcnJheTxXZWVrPiB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRBY3Rpdml0aWVzID0gZmlsbEhvbGVzKGFjdGl2aXRpZXMpXG5cbiAgLy8gRGV0ZXJtaW5lIHRoZSBmaXJzdCBkYXRlIG9mIHRoZSBjYWxlbmRhci4gSWYgdGhlIGZpcnN0IGRhdGUgaXMgbm90IHRoZVxuICAvLyBwYXNzZWQgd2Vla2RheSwgdGhlIHJlc3BlY3RpdmUgd2Vla2RheSBvbmUgd2VlayBlYXJsaWVyIGlzIHVzZWQuXG4gIGNvbnN0IGZpcnN0QWN0aXZpdHkgPSBub3JtYWxpemVkQWN0aXZpdGllc1swXSBhcyBBY3Rpdml0eVxuICBjb25zdCBmaXJzdERhdGUgPSBwYXJzZUlTTyhmaXJzdEFjdGl2aXR5LmRhdGUpXG4gIGNvbnN0IGZpcnN0Q2FsZW5kYXJEYXRlID1cbiAgICBnZXREYXkoZmlyc3REYXRlKSA9PT0gd2Vla1N0YXJ0ID8gZmlyc3REYXRlIDogc3ViV2Vla3MobmV4dERheShmaXJzdERhdGUsIHdlZWtTdGFydCksIDEpXG5cbiAgLy8gVG8gY29ycmVjdGx5IGdyb3VwIGFjdGl2aXRpZXMgYnkgd2VlaywgaXQgaXMgbmVjZXNzYXJ5IHRvIGxlZnQtcGFkIHRoZSBsaXN0XG4gIC8vIGJlY2F1c2UgdGhlIGZpcnN0IGRhdGUgbWlnaHQgbm90IGJlIHNldCBzdGFydCB3ZWVrZGF5LlxuICBjb25zdCBwYWRkZWRBY3Rpdml0aWVzID0gW1xuICAgIC4uLihBcnJheShkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoZmlyc3REYXRlLCBmaXJzdENhbGVuZGFyRGF0ZSkpLmZpbGwoXG4gICAgICB1bmRlZmluZWQsXG4gICAgKSBhcyBBcnJheTxBY3Rpdml0eT4pLFxuICAgIC4uLm5vcm1hbGl6ZWRBY3Rpdml0aWVzLFxuICBdXG5cbiAgY29uc3QgbnVtYmVyT2ZXZWVrcyA9IE1hdGguY2VpbChwYWRkZWRBY3Rpdml0aWVzLmxlbmd0aCAvIDcpXG5cbiAgLy8gRmluYWxseSwgZ3JvdXAgYWN0aXZpdGllcyBieSB3ZWVrXG4gIHJldHVybiByYW5nZShudW1iZXJPZldlZWtzKS5tYXAod2Vla0luZGV4ID0+XG4gICAgcGFkZGVkQWN0aXZpdGllcy5zbGljZSh3ZWVrSW5kZXggKiA3LCB3ZWVrSW5kZXggKiA3ICsgNyksXG4gIClcbn1cblxuLyoqXG4gKiBUaGUgY2FsZW5kYXIgZXhwZWN0cyBhIGNvbnRpbnVvdXMgc2VxdWVuY2Ugb2YgZGF5cyxcbiAqIHNvIGZpbGwgZ2FwcyB3aXRoIGVtcHR5IGFjdGl2aXR5IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGZpbGxIb2xlcyhhY3Rpdml0aWVzOiBBcnJheTxBY3Rpdml0eT4pOiBBcnJheTxBY3Rpdml0eT4ge1xuICBjb25zdCBjYWxlbmRhciA9IG5ldyBNYXA8c3RyaW5nLCBBY3Rpdml0eT4oYWN0aXZpdGllcy5tYXAoYSA9PiBbYS5kYXRlLCBhXSkpXG4gIGNvbnN0IGZpcnN0QWN0aXZpdHkgPSBhY3Rpdml0aWVzWzBdIGFzIEFjdGl2aXR5XG4gIGNvbnN0IGxhc3RBY3Rpdml0eSA9IGFjdGl2aXRpZXNbYWN0aXZpdGllcy5sZW5ndGggLSAxXSBhcyBBY3Rpdml0eVxuXG4gIHJldHVybiBlYWNoRGF5T2ZJbnRlcnZhbCh7XG4gICAgc3RhcnQ6IHBhcnNlSVNPKGZpcnN0QWN0aXZpdHkuZGF0ZSksXG4gICAgZW5kOiBwYXJzZUlTTyhsYXN0QWN0aXZpdHkuZGF0ZSksXG4gIH0pLm1hcChkYXkgPT4ge1xuICAgIGNvbnN0IGRhdGUgPSBmb3JtYXRJU08oZGF5LCB7IHJlcHJlc2VudGF0aW9uOiAnZGF0ZScgfSlcblxuICAgIGlmIChjYWxlbmRhci5oYXMoZGF0ZSkpIHtcbiAgICAgIHJldHVybiBjYWxlbmRhci5nZXQoZGF0ZSkgYXMgQWN0aXZpdHlcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0ZSxcbiAgICAgIGNvdW50OiAwLFxuICAgICAgbGV2ZWw6IDAsXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKG5hbWU6IHN0cmluZykge1xuICByZXR1cm4gYCR7TkFNRVNQQUNFfV9fJHtuYW1lfWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRW1wdHlEYXRhKCk6IEFycmF5PEFjdGl2aXR5PiB7XG4gIGNvbnN0IHllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKClcbiAgY29uc3QgZGF5cyA9IGVhY2hEYXlPZkludGVydmFsKHtcbiAgICBzdGFydDogbmV3IERhdGUoeWVhciwgMCwgMSksXG4gICAgZW5kOiBuZXcgRGF0ZSh5ZWFyLCAxMSwgMzEpLFxuICB9KVxuXG4gIHJldHVybiBkYXlzLm1hcChkYXRlID0+ICh7XG4gICAgZGF0ZTogZm9ybWF0SVNPKGRhdGUsIHsgcmVwcmVzZW50YXRpb246ICdkYXRlJyB9KSxcbiAgICBjb3VudDogMCxcbiAgICBsZXZlbDogMCxcbiAgfSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRlc3REYXRhKGFyZ3M6IHtcbiAgaW50ZXJ2YWw/OiB7IHN0YXJ0OiBEYXRlOyBlbmQ6IERhdGUgfVxuICBtYXhMZXZlbD86IG51bWJlclxufSk6IEFycmF5PEFjdGl2aXR5PiB7XG4gIGNvbnN0IG1heENvdW50ID0gMjBcbiAgY29uc3QgbWF4TGV2ZWwgPSBhcmdzLm1heExldmVsID8gTWF0aC5tYXgoMSwgYXJncy5tYXhMZXZlbCkgOiA0XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcblxuICBjb25zdCBkYXlzID0gZWFjaERheU9mSW50ZXJ2YWwoXG4gICAgYXJncy5pbnRlcnZhbCA/PyB7XG4gICAgICBzdGFydDogc3RhcnRPZlllYXIobm93KSxcbiAgICAgIGVuZDogZW5kT2ZZZWFyKG5vdyksXG4gICAgfSxcbiAgKVxuXG4gIHJldHVybiBkYXlzLm1hcChkYXRlID0+IHtcbiAgICAvLyBUaGUgcmFuZG9tIGFjdGl2aXR5IGNvdW50IGlzIHNoaWZ0ZWQgYnkgdXAgdG8gODAlIHRvd2FyZHMgemVyby5cbiAgICBjb25zdCBjID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogbWF4Q291bnQgLSBNYXRoLnJhbmRvbSgpICogKDAuOCAqIG1heENvdW50KSlcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWF4KDAsIGMpXG4gICAgY29uc3QgbGV2ZWwgPSBNYXRoLmNlaWwoKGNvdW50IC8gbWF4Q291bnQpICogbWF4TGV2ZWwpXG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0ZTogZm9ybWF0SVNPKGRhdGUsIHsgcmVwcmVzZW50YXRpb246ICdkYXRlJyB9KSxcbiAgICAgIGNvdW50LFxuICAgICAgbGV2ZWwsXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2UobjogbnVtYmVyKSB7XG4gIHJldHVybiBbLi4uQXJyYXkobikua2V5cygpXVxufVxuIiwiaW1wb3J0IHsgZ2V0TW9udGgsIHBhcnNlSVNPIH0gZnJvbSAnZGF0ZS1mbnMnXG5pbXBvcnQgdHlwZSB7IFByb3BzIH0gZnJvbSAnLi4vY29tcG9uZW50L0FjdGl2aXR5Q2FsZW5kYXInXG5pbXBvcnQgeyBERUZBVUxUX01PTlRIX0xBQkVMUyB9IGZyb20gJy4uL2NvbnN0YW50cydcbmltcG9ydCB0eXBlIHsgRGF5SW5kZXgsIERheU5hbWUsIFdlZWssIFdlZWtkYXlMYWJlbHMgfSBmcm9tICcuLi90eXBlcydcblxudHlwZSBNb250aExhYmVsID0ge1xuICB3ZWVrSW5kZXg6IG51bWJlclxuICBsYWJlbDogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb250aExhYmVscyhcbiAgd2Vla3M6IEFycmF5PFdlZWs+LFxuICBtb250aE5hbWVzOiBBcnJheTxzdHJpbmc+ID0gREVGQVVMVF9NT05USF9MQUJFTFMsXG4pOiBBcnJheTxNb250aExhYmVsPiB7XG4gIHJldHVybiB3ZWVrc1xuICAgIC5yZWR1Y2U8QXJyYXk8TW9udGhMYWJlbD4+KChsYWJlbHMsIHdlZWssIHdlZWtJbmRleCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RBY3Rpdml0eSA9IHdlZWsuZmluZChhY3Rpdml0eSA9PiBhY3Rpdml0eSAhPT0gdW5kZWZpbmVkKVxuXG4gICAgICBpZiAoIWZpcnN0QWN0aXZpdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGVycm9yOiBXZWVrICR7d2Vla0luZGV4ICsgMX0gaXMgZW1wdHkuYClcbiAgICAgIH1cblxuICAgICAgY29uc3QgbW9udGggPSBtb250aE5hbWVzW2dldE1vbnRoKHBhcnNlSVNPKGZpcnN0QWN0aXZpdHkuZGF0ZSkpXVxuXG4gICAgICBpZiAoIW1vbnRoKSB7XG4gICAgICAgIGNvbnN0IG1vbnRoTmFtZSA9IG5ldyBEYXRlKGZpcnN0QWN0aXZpdHkuZGF0ZSkudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJywgeyBtb250aDogJ3Nob3J0JyB9KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZXJyb3I6IHVuZGVmaW5lZCBtb250aCBsYWJlbCBmb3IgJHttb250aE5hbWV9LmApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByZXZMYWJlbCA9IGxhYmVsc1tsYWJlbHMubGVuZ3RoIC0gMV1cblxuICAgICAgaWYgKHdlZWtJbmRleCA9PT0gMCB8fCAhcHJldkxhYmVsIHx8IHByZXZMYWJlbC5sYWJlbCAhPT0gbW9udGgpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5sYWJlbHMsIHsgd2Vla0luZGV4LCBsYWJlbDogbW9udGggfV1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxhYmVsc1xuICAgIH0sIFtdKVxuICAgIC5maWx0ZXIoKHsgd2Vla0luZGV4IH0sIGluZGV4LCBsYWJlbHMpID0+IHtcbiAgICAgIC8vIExhYmVscyBzaG91bGQgb25seSBiZSBzaG93biBpZiB0aGVyZSBpcyBcImVub3VnaFwiIHNwYWNlIChkYXRhKS5cbiAgICAgIC8vIFRoaXMgaXMgYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXMgbm90IHRha2UgdGhlIGJsb2NrIHNpemUsXG4gICAgICAvLyBmb250IHNpemUsIGV0Yy4gaW50byBhY2NvdW50LlxuICAgICAgY29uc3QgbWluV2Vla3MgPSAzXG5cbiAgICAgIC8vIFNraXAgdGhlIGZpcnN0IG1vbnRoIGxhYmVsIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgdG8gdGhlIG5leHQgb25lLlxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBsYWJlbHNbMV0gJiYgbGFiZWxzWzFdLndlZWtJbmRleCAtIHdlZWtJbmRleCA+PSBtaW5XZWVrc1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIHRoZSBsYXN0IG1vbnRoIGxhYmVsIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggZGF0YSBpbiB0aGF0IG1vbnRoXG4gICAgICAvLyB0byBhdm9pZCBvdmVyZmxvd2luZyB0aGUgY2FsZW5kYXIgb24gdGhlIHJpZ2h0LlxuICAgICAgaWYgKGluZGV4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gd2Vla3Muc2xpY2Uod2Vla0luZGV4KS5sZW5ndGggPj0gbWluV2Vla3NcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF4V2Vla2RheUxhYmVsV2lkdGgoXG4gIGxhYmVsczogQXJyYXk8c3RyaW5nPixcbiAgc2hvd1dlZWtkYXlMYWJlbDogV2Vla2RheUxhYmVscyxcbiAgZm9udFNpemU6IG51bWJlcixcbik6IG51bWJlciB7XG4gIGlmIChsYWJlbHMubGVuZ3RoICE9PSA3KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeGFjdGx5IDcgbGFiZWxzLCBvbmUgZm9yIGVhY2ggd2Vla2RheSBtdXN0IGJlIHBhc3NlZC4nKVxuICB9XG5cbiAgcmV0dXJuIGxhYmVscy5yZWR1Y2UoXG4gICAgKG1heFdpZHRoLCBsYWJlbCwgaW5kZXgpID0+XG4gICAgICBzaG93V2Vla2RheUxhYmVsLmJ5RGF5SW5kZXgoaW5kZXggYXMgRGF5SW5kZXgpXG4gICAgICAgID8gTWF0aC5tYXgobWF4V2lkdGgsIE1hdGguY2VpbChjYWxjVGV4dERpbWVuc2lvbnMobGFiZWwsIGZvbnRTaXplKS53aWR0aCkpXG4gICAgICAgIDogbWF4V2lkdGgsXG4gICAgMCxcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY1RleHREaW1lbnNpb25zKHRleHQ6IHN0cmluZywgZm9udFNpemU6IG51bWJlcikge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfVxuICB9XG5cbiAgaWYgKGZvbnRTaXplIDwgMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmb250U2l6ZSBtdXN0IGJlIHBvc2l0aXZlJylcbiAgfVxuXG4gIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfVxuICB9XG5cbiAgY29uc3QgbmFtZXNwYWNlID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xuICBjb25zdCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCAnc3ZnJylcblxuICBzdmcuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gIHN2Zy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgc3ZnLnN0eWxlLmZvbnRGYW1pbHkgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5mb250RmFtaWx5XG4gIHN2Zy5zdHlsZS5mb250U2l6ZSA9IGAke2ZvbnRTaXplfXB4YFxuXG4gIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgJ3RleHQnKVxuICB0ZXh0Tm9kZS50ZXh0Q29udGVudCA9IHRleHRcblxuICBzdmcuYXBwZW5kQ2hpbGQodGV4dE5vZGUpXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnKVxuICBjb25zdCBib3VuZGluZ0JveCA9IHRleHROb2RlLmdldEJCb3goKVxuXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3ZnKVxuXG4gIHJldHVybiB7IHdpZHRoOiBib3VuZGluZ0JveC53aWR0aCwgaGVpZ2h0OiBib3VuZGluZ0JveC5oZWlnaHQgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFdlZWtkYXlMYWJlbHMoXG4gIGlucHV0OiBQcm9wc1snc2hvd1dlZWtkYXlMYWJlbHMnXSxcbiAgd2Vla1N0YXJ0OiBEYXlJbmRleCxcbik6IFdlZWtkYXlMYWJlbHMge1xuICBpZiAoIWlucHV0KVxuICAgIHJldHVybiB7XG4gICAgICBieURheUluZGV4OiAoKSA9PiBmYWxzZSxcbiAgICAgIHNob3VsZFNob3c6IGZhbHNlLFxuICAgIH1cblxuICAvLyBEZWZhdWx0OiBTaG93IGV2ZXJ5IHNlY29uZCBkYXkgb2YgdGhlIHdlZWsuXG4gIGlmIChpbnB1dCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBieURheUluZGV4OiBpbmRleCA9PiB7XG4gICAgICAgIHJldHVybiAoKDcgKyBpbmRleCAtIHdlZWtTdGFydCkgJSA3KSAlIDIgIT09IDBcbiAgICAgIH0sXG4gICAgICBzaG91bGRTaG93OiB0cnVlLFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGluZGV4ZWQ6IEFycmF5PGJvb2xlYW4+ID0gW11cbiAgZm9yIChjb25zdCBuYW1lIG9mIGlucHV0KSB7XG4gICAgY29uc3QgaW5kZXggPSBkYXlOYW1lVG9JbmRleFtuYW1lLnRvTG93ZXJDYXNlKCkgYXMgRGF5TmFtZV1cbiAgICBpbmRleGVkW2luZGV4XSA9IHRydWVcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYnlEYXlJbmRleDogaW5kZXggPT4gaW5kZXhlZFtpbmRleF0gPz8gZmFsc2UsXG4gICAgc2hvdWxkU2hvdzogaW5wdXQubGVuZ3RoID4gMCxcbiAgfVxufVxuXG5jb25zdCBkYXlOYW1lVG9JbmRleDogUmVjb3JkPERheU5hbWUsIERheUluZGV4PiA9IHtcbiAgc3VuOiAwLFxuICBtb246IDEsXG4gIHR1ZTogMixcbiAgd2VkOiAzLFxuICB0aHU6IDQsXG4gIGZyaTogNSxcbiAgc2F0OiA2LFxufVxuIiwiaW1wb3J0IHR5cGUgeyBDb2xvciwgQ29sb3JTY2FsZSwgVGhlbWUsIFRoZW1lSW5wdXQgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IHJhbmdlIH0gZnJvbSAnLi9jYWxlbmRhcidcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRoZW1lKGlucHV0PzogVGhlbWVJbnB1dCwgc3RlcHMgPSA1KTogVGhlbWUge1xuICBjb25zdCBkZWZhdWx0VGhlbWUgPSBjcmVhdGVEZWZhdWx0VGhlbWUoc3RlcHMpXG5cbiAgaWYgKGlucHV0KSB7XG4gICAgdmFsaWRhdGVUaGVtZUlucHV0KGlucHV0LCBzdGVwcylcblxuICAgIGlucHV0LmxpZ2h0ID0gaW5wdXQubGlnaHQgPz8gZGVmYXVsdFRoZW1lLmxpZ2h0XG4gICAgaW5wdXQuZGFyayA9IGlucHV0LmRhcmsgPz8gZGVmYXVsdFRoZW1lLmRhcmtcblxuICAgIHJldHVybiB7XG4gICAgICBsaWdodDogaXNQYWlyKGlucHV0LmxpZ2h0KSA/IGNhbGNDb2xvclNjYWxlKGlucHV0LmxpZ2h0LCBzdGVwcykgOiBpbnB1dC5saWdodCxcbiAgICAgIGRhcms6IGlzUGFpcihpbnB1dC5kYXJrKSA/IGNhbGNDb2xvclNjYWxlKGlucHV0LmRhcmssIHN0ZXBzKSA6IGlucHV0LmRhcmssXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRUaGVtZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0VGhlbWUoc3RlcHM6IG51bWJlcik6IFRoZW1lIHtcbiAgcmV0dXJuIHtcbiAgICBsaWdodDogY2FsY0NvbG9yU2NhbGUoWydoc2woMCwgMCUsIDkyJSknLCAnaHNsKDAsIDAlLCAyNiUpJ10sIHN0ZXBzKSxcbiAgICBkYXJrOiBjYWxjQ29sb3JTY2FsZShbJ2hzbCgwLCAwJSwgMjIlKScsICdoc2woMCwgMCUsIDkyJSknXSwgc3RlcHMpLFxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGhlbWVJbnB1dChpbnB1dDogVGhlbWVJbnB1dCwgc3RlcHM6IG51bWJlcikge1xuICBjb25zdCBtYXhMZXZlbEhpbnQgPSAnVGhlIG51bWJlciBvZiBjb2xvcnMgaXMgY29udHJvbGxlZCBieSB0aGUgXCJtYXhMZXZlbFwiIHByb3BlcnR5LidcblxuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyB8fCAoaW5wdXQubGlnaHQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dC5kYXJrID09PSB1bmRlZmluZWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSB0aGVtZSBvYmplY3QgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBvZiB0aGUgZmllbGRzIFwibGlnaHRcIiBhbmQgXCJkYXJrXCIgd2l0aCBleGFjdGx5IDIgb3IgJHtzdGVwc30gY29sb3JzIHJlc3BlY3RpdmVseS4gJHttYXhMZXZlbEhpbnR9YCxcbiAgICApXG4gIH1cblxuICBpZiAoaW5wdXQubGlnaHQpIHtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gaW5wdXQubGlnaHRcbiAgICBpZiAobGVuZ3RoICE9PSAyICYmIGxlbmd0aCAhPT0gc3RlcHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYHRoZW1lLmxpZ2h0IG11c3QgY29udGFpbiBleGFjdGx5IDIgb3IgJHtzdGVwc30gY29sb3JzLCAke2xlbmd0aH0gcGFzc2VkLiAke21heExldmVsSGludH1gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgYyBvZiBpbnB1dC5saWdodCkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICFDU1Muc3VwcG9ydHMoJ2NvbG9yJywgYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbG9yIFwiJHtjfVwiIHBhc3NlZC4gQWxsIENTUyBjb2xvciBmb3JtYXRzIGFyZSBhY2NlcHRlZC5gKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnB1dC5kYXJrKSB7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGlucHV0LmRhcmtcbiAgICBpZiAobGVuZ3RoICE9PSAyICYmIGxlbmd0aCAhPT0gc3RlcHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYHRoZW1lLmRhcmsgbXVzdCBjb250YWluIGV4YWN0bHkgMiBvciAke3N0ZXBzfSBjb2xvcnMsICR7bGVuZ3RofSBwYXNzZWQuICR7bWF4TGV2ZWxIaW50fWAsXG4gICAgICApXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBjIG9mIGlucHV0LmRhcmspIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhQ1NTLnN1cHBvcnRzKCdjb2xvcicsIGMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2xvciBcIiR7Y31cIiBwYXNzZWQuIEFsbCBDU1MgY29sb3IgZm9ybWF0cyBhcmUgYWNjZXB0ZWQuYClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY0NvbG9yU2NhbGUoW3N0YXJ0LCBlbmRdOiBbQ29sb3IsIENvbG9yXSwgc3RlcHM6IG51bWJlcik6IENvbG9yU2NhbGUge1xuICByZXR1cm4gcmFuZ2Uoc3RlcHMpLm1hcChpID0+IHtcbiAgICAvLyBJbiB0aGUgbG9hZGluZyBhbmltYXRpb24gdGhlIHplcm8gY29sb3IgaXMgdXNlZC5cbiAgICAvLyBIb3dldmVyLCBTYWZhcmkgMTYgY3Jhc2hlcyBpZiBhIENTUyBjb2xvci1taXggZXhwcmVzc2lvbiBsaWtlIGJlbG93IGlzXG4gICAgLy8gY29tYmluZWQgd2l0aCByZWxhdGl2ZSBjb2xvciBzeW50YXggdG8gY2FsY3VsYXRlIGEgaHVlIHZhcmlhdGlvbiBmb3IgdGhlXG4gICAgLy8gYW5pbWF0aW9uLiBTaW5jZSB0aGUgc3RhcnQgYW5kIGVuZCBjb2xvcnMgZG8gbm90IG5lZWQgdG8gYmUgbWl4ZWQsIHRoZXlcbiAgICAvLyBjYW4gYmUgcmV0dXJuZWQgZGlyZWN0bHkgdG8gd29yayBhcm91bmQgdGhpcyBpc3N1ZS5cbiAgICBzd2l0Y2ggKGkpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHN0YXJ0XG4gICAgICBjYXNlIHN0ZXBzIC0gMTpcbiAgICAgICAgcmV0dXJuIGVuZFxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBwb3MgPSAoaSAvIChzdGVwcyAtIDEpKSAqIDEwMFxuICAgICAgICByZXR1cm4gYGNvbG9yLW1peChpbiBva2xhYiwgJHtlbmR9ICR7cGFyc2VGbG9hdChwb3MudG9GaXhlZCgyKSl9JSwgJHtzdGFydH0pYFxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNQYWlyPFQ+KHZhbDogQXJyYXk8VD4pOiB2YWwgaXMgW1QsIFRdIHtcbiAgcmV0dXJuIHZhbC5sZW5ndGggPT09IDJcbn1cbiIsImltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3Qgc3R5bGVzID0ge1xuICBjb250YWluZXI6IChmb250U2l6ZTogbnVtYmVyKSA9PlxuICAgICh7XG4gICAgICB3aWR0aDogJ21heC1jb250ZW50JywgLy8gQ2FsZW5kYXIgc2hvdWxkIG5vdCBncm93XG4gICAgICBtYXhXaWR0aDogJzEwMCUnLCAvLyBEbyBub3QgcmVtb3ZlIC0gcGFyZW50IG1pZ2h0IGJlIGEgZmxleGJveFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICBnYXA6ICc4cHgnLFxuICAgICAgZm9udFNpemU6IGAke2ZvbnRTaXplfXB4YCxcbiAgICB9KSBzYXRpc2ZpZXMgQ1NTUHJvcGVydGllcyxcbiAgc2Nyb2xsQ29udGFpbmVyOiAoZm9udFNpemU6IG51bWJlcikgPT5cbiAgICAoe1xuICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgIG92ZXJmbG93WDogJ2F1dG8nLFxuICAgICAgb3ZlcmZsb3dZOiAnaGlkZGVuJyxcbiAgICAgIHBhZGRpbmdUb3A6IE1hdGguY2VpbCgwLjEgKiBmb250U2l6ZSksIC8vIFNWRyA8dGV4dD4gb3ZlcmZsb3dzIGluIEZpcmVmb3ggYXQgeT0wXG4gICAgfSkgc2F0aXNmaWVzIENTU1Byb3BlcnRpZXMsXG4gIGNhbGVuZGFyOiB7XG4gICAgZGlzcGxheTogJ2Jsb2NrJywgLy8gU1ZHcyBhcmUgaW5saW5lLWJsb2NrIGJ5IGRlZmF1bHRcbiAgICBvdmVyZmxvdzogJ3Zpc2libGUnLCAvLyBXZWVrZGF5IGxhYmVscyBhcmUgcmVuZGVyZWQgbGVmdCBvZiB0aGUgY29udGFpbmVyXG4gIH0gc2F0aXNmaWVzIENTU1Byb3BlcnRpZXMsXG4gIHJlY3Q6IChjb2xvclNjaGVtZTogJ2xpZ2h0JyB8ICdkYXJrJykgPT5cbiAgICAoe1xuICAgICAgc3Ryb2tlOiBjb2xvclNjaGVtZSA9PT0gJ2xpZ2h0JyA/ICdyZ2JhKDAsIDAsIDAsIDAuMDgpJyA6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDQpJyxcbiAgICB9KSBzYXRpc2ZpZXMgQ1NTUHJvcGVydGllcyxcbiAgZm9vdGVyOiB7XG4gICAgY29udGFpbmVyOiB7XG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBmbGV4V3JhcDogJ3dyYXAnLFxuICAgICAgZ2FwOiAnNHB4IDE2cHgnLFxuICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgfSBzYXRpc2ZpZXMgQ1NTUHJvcGVydGllcyxcbiAgICBsZWdlbmQ6IHtcbiAgICAgIG1hcmdpbkxlZnQ6ICdhdXRvJyxcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgZ2FwOiAnM3B4JyxcbiAgICB9IHNhdGlzZmllcyBDU1NQcm9wZXJ0aWVzLFxuICB9LFxufVxuIiwiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7XG4gIGZvcndhcmRSZWYsXG4gIEZyYWdtZW50LFxuICB1c2VFZmZlY3QsXG4gIHVzZVN0YXRlLFxuICB0eXBlIENTU1Byb3BlcnRpZXMsXG4gIHR5cGUgRm9yd2FyZGVkUmVmLFxuICB0eXBlIFJlYWN0RWxlbWVudCxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBnZXRZZWFyLCBwYXJzZUlTTyB9IGZyb20gJ2RhdGUtZm5zJ1xuaW1wb3J0IHsgREVGQVVMVF9MQUJFTFMsIExBQkVMX01BUkdJTiwgTkFNRVNQQUNFIH0gZnJvbSAnLi4vY29uc3RhbnRzJ1xuaW1wb3J0IHsgdXNlQ29sb3JTY2hlbWUgfSBmcm9tICcuLi9ob29rcy91c2VDb2xvclNjaGVtZSdcbmltcG9ydCB7IGxvYWRpbmdBbmltYXRpb25OYW1lLCB1c2VMb2FkaW5nQW5pbWF0aW9uIH0gZnJvbSAnLi4vaG9va3MvdXNlTG9hZGluZ0FuaW1hdGlvbidcbmltcG9ydCB7IHVzZVByZWZlcnNSZWR1Y2VkTW90aW9uIH0gZnJvbSAnLi4vaG9va3MvdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24nXG5pbXBvcnQge1xuICBnZW5lcmF0ZUVtcHR5RGF0YSxcbiAgZ2V0Q2xhc3NOYW1lLFxuICBncm91cEJ5V2Vla3MsXG4gIHJhbmdlLFxuICB2YWxpZGF0ZUFjdGl2aXRpZXMsXG59IGZyb20gJy4uL2xpYi9jYWxlbmRhcidcbmltcG9ydCB7IGdldE1vbnRoTGFiZWxzLCBpbml0V2Vla2RheUxhYmVscywgbWF4V2Vla2RheUxhYmVsV2lkdGggfSBmcm9tICcuLi9saWIvbGFiZWwnXG5pbXBvcnQgeyBjcmVhdGVUaGVtZSB9IGZyb20gJy4uL2xpYi90aGVtZSdcbmltcG9ydCB0eXBlIHtcbiAgQWN0aXZpdHksXG4gIEJsb2NrRWxlbWVudCxcbiAgRGF5SW5kZXgsXG4gIERheU5hbWUsXG4gIEV2ZW50SGFuZGxlck1hcCxcbiAgTGFiZWxzLFxuICBSZWFjdEV2ZW50LFxuICBTVkdSZWN0RXZlbnRIYW5kbGVyLFxuICBUaGVtZUlucHV0LFxufSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IHN0eWxlcyB9IGZyb20gJy4vc3R5bGVzJ1xuXG5leHBvcnQgdHlwZSBQcm9wcyA9IHtcbiAgLyoqXG4gICAqIExpc3Qgb2YgY2FsZW5kYXIgZW50cmllcy4gRXZlcnkgYEFjdGl2aXR5YCBvYmplY3QgcmVxdWlyZXMgYW4gSVNPIDg2MDFcbiAgICogYGRhdGVgIHN0cmluZyBpbiB0aGUgZm9ybWF0IGB5eXl5LU1NLWRkYCwgYSBgY291bnRgIHByb3BlcnR5IHdpdGggdGhlXG4gICAqIGFtb3VudCBvZiB0cmFja2VkIGRhdGEgYW5kIGEgYGxldmVsYCBwcm9wZXJ0eSBpbiB0aGUgcmFuZ2UgYDAtbWF4TGV2ZWxgXG4gICAqIHRvIHNwZWNpZnkgYWN0aXZpdHkgaW50ZW5zaXR5LiBUaGUgYG1heExldmVsYCBwcm9wIGlzIDQgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogRm9yIG1pc3NpbmcgZGF0ZXMsIG5vIGFjdGl2aXR5IGlzIGFzc3VtZWQuIFRoaXMgYWxsb3dzIGNob29zaW5nIHRoZSBzdGFydFxuICAgKiBhbmQgZW5kIGRhdGUgb2YgdGhlIGNhbGVuZGFyIGFyYml0cmFyaWx5IGJ5IHBhc3NpbmcgZW1wdHkgZW50cmllcyBhcyB0aGVcbiAgICogZmlyc3QgYW5kIGxhc3QgaXRlbS5cbiAgICpcbiAgICogRXhhbXBsZSBvYmplY3Q6XG4gICAqXG4gICAqIGBgYGpzb25cbiAgICoge1xuICAgKiAgIGRhdGU6IFwiMjAyMS0wMi0yMFwiLFxuICAgKiAgIGNvdW50OiAxNixcbiAgICogICBsZXZlbDogM1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgZGF0YTogQXJyYXk8QWN0aXZpdHk+XG4gIC8qKlxuICAgKiBNYXJnaW4gYmV0d2VlbiBibG9ja3MgaW4gcGl4ZWxzLlxuICAgKi9cbiAgYmxvY2tNYXJnaW4/OiBudW1iZXJcbiAgLyoqXG4gICAqIEJvcmRlciByYWRpdXMgb2YgYmxvY2tzIGluIHBpeGVscy5cbiAgICovXG4gIGJsb2NrUmFkaXVzPzogbnVtYmVyXG4gIC8qKlxuICAgKiBCbG9jayBzaXplIGluIHBpeGVscy5cbiAgICovXG4gIGJsb2NrU2l6ZT86IG51bWJlclxuICAvKipcbiAgICogVXNlIGEgc3BlY2lmaWMgY29sb3Igc2NoZW1lIGluc3RlYWQgb2YgdGhlIHN5c3RlbSBvbmUuIFN1cHBvcnRlZCB2YWx1ZXNcbiAgICogYXJlIGAnbGlnaHQnYCBhbmQgYCdkYXJrJ2AuXG4gICAqL1xuICBjb2xvclNjaGVtZT86ICdsaWdodCcgfCAnZGFyaydcbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXJzIHRvIHJlZ2lzdGVyIGZvciB0aGUgU1ZHIGA8cmVjdD5gIGVsZW1lbnRzIHRoYXQgYXJlIHVzZWQgdG9cbiAgICogcmVuZGVyIHRoZSBjYWxlbmRhciBkYXlzLiBIYW5kbGVyIHNpZ25hdHVyZTogYGV2ZW50ID0+IGFjdGl2aXR5ID0+IHZvaWRgXG4gICAqL1xuICBldmVudEhhbmRsZXJzPzogRXZlbnRIYW5kbGVyTWFwXG4gIC8qKlxuICAgKiBGb250IHNpemUgZm9yIHRleHQgaW4gcGl4ZWxzLlxuICAgKi9cbiAgZm9udFNpemU/OiBudW1iZXJcbiAgLyoqXG4gICAqIFRvZ2dsZSB0byBoaWRlIGNvbG9yIGxlZ2VuZCBiZWxvdyBjYWxlbmRhci5cbiAgICovXG4gIGhpZGVDb2xvckxlZ2VuZD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0byBoaWRlIG1vbnRoIGxhYmVscyBhYm92ZSBjYWxlbmRhci5cbiAgICovXG4gIGhpZGVNb250aExhYmVscz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0byBoaWRlIHRoZSB0b3RhbCBjb3VudCBiZWxvdyBjYWxlbmRhci5cbiAgICovXG4gIGhpZGVUb3RhbENvdW50PzogYm9vbGVhblxuICAvKipcbiAgICogTG9jYWxpemF0aW9uIHN0cmluZ3MgZm9yIGFsbCBjYWxlbmRhciBsYWJlbHMuXG4gICAqXG4gICAqIGB0b3RhbENvdW50YCBzdXBwb3J0cyB0aGUgcGxhY2Vob2xkZXJzIGB7e2NvdW50fX1gIGFuZCBge3t5ZWFyfX1gLlxuICAgKi9cbiAgbGFiZWxzPzogTGFiZWxzXG4gIC8qKlxuICAgKiBNYXhpbXVtIGFjdGl2aXR5IGxldmVsICh6ZXJvLWluZGV4ZWQpLiA0IHBlciBkZWZhdWx0LCAwIG1lYW5zIFwibm8gYWN0aXZpdHlcIi5cbiAgICovXG4gIG1heExldmVsPzogbnVtYmVyXG4gIC8qKlxuICAgKiBUb2dnbGUgZm9yIGxvYWRpbmcgc3RhdGUuIGBkYXRhYCBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQgaWYgc2V0LlxuICAgKi9cbiAgbG9hZGluZz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJlZiB0byBhY2Nlc3MgdGhlIGNhbGVuZGFyIERPTSBub2RlLlxuICAgKi9cbiAgcmVmPzogRm9yd2FyZGVkUmVmPEhUTUxFbGVtZW50PlxuICAvKipcbiAgICogUmVuZGVyIHByb3AgZm9yIGNhbGVuZGFyIGJsb2NrcyAoYWN0aXZpdGllcykuIEZvciBleGFtcGxlLCB1c2VmdWwgdG8gd3JhcFxuICAgKiB0aGUgZWxlbWVudCB3aXRoIGEgdG9vbHRpcCBjb21wb25lbnQuIFVzZSBgUmVhY3QuY2xvbmVFbGVtZW50YCB0byBwYXNzXG4gICAqIGFkZGl0aW9uYWwgcHJvcHMgdG8gdGhlIGVsZW1lbnQgaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgcmVuZGVyQmxvY2s/OiAoYmxvY2s6IEJsb2NrRWxlbWVudCwgYWN0aXZpdHk6IEFjdGl2aXR5KSA9PiBSZWFjdEVsZW1lbnRcbiAgLyoqXG4gICAqIFJlbmRlciBwcm9wIGZvciBjb2xvciBsZWdlbmQgYmxvY2tzLiBGb3IgZXhhbXBsZSwgdXNlZnVsIHRvIHdyYXAgdGhlXG4gICAqIGVsZW1lbnQgd2l0aCBhIHRvb2x0aXAgY29tcG9uZW50LiBVc2UgYFJlYWN0LmNsb25lRWxlbWVudGAgdG8gcGFzc1xuICAgKiBhZGRpdGlvbmFsIHByb3BzIHRvIHRoZSBlbGVtZW50IGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIHJlbmRlckNvbG9yTGVnZW5kPzogKGJsb2NrOiBCbG9ja0VsZW1lbnQsIGxldmVsOiBudW1iZXIpID0+IFJlYWN0RWxlbWVudFxuICAvKipcbiAgICogVG9nZ2xlIHRvIHNob3cgd2Vla2RheSBsYWJlbHMgbGVmdCB0byB0aGUgY2FsZW5kYXIuXG4gICAqIEFsdGVybmF0aXZlbHksIHBhc3MgYSBsaXN0IG9mIElTTyA4NjAxIHdlZWtkYXkgbmFtZXMgdG8gc2hvdy5cbiAgICogRm9yIGV4YW1wbGUgYFsnbW9uJywgJ3dlZCcsICdmcmknXWAuXG4gICAqL1xuICBzaG93V2Vla2RheUxhYmVscz86IGJvb2xlYW4gfCBBcnJheTxEYXlOYW1lPlxuICAvKipcbiAgICogU3R5bGUgb2JqZWN0IHRvIHBhc3MgdG8gY29tcG9uZW50IGNvbnRhaW5lci5cbiAgICovXG4gIHN0eWxlPzogQ1NTUHJvcGVydGllc1xuICAvKipcbiAgICogU2V0IHRoZSBjYWxlbmRhciBjb2xvcnMgZm9yIHRoZSBsaWdodCBhbmQgZGFyayBzeXN0ZW0gY29sb3Igc2NoZW1lLiBQYXNzXG4gICAqIGFsbCBjb2xvcnMgcGVyIHNjaGVtZSBleHBsaWNpdGx5ICg1IHBlciBkZWZhdWx0KSBvciBzZXQgZXhhY3RseSB0d28gY29sb3JzXG4gICAqICh0aGUgbG93ZXN0IGFuZCBoaWdoZXN0IGludGVuc2l0eSkgdG8gY2FsY3VsYXRlIGEgc2luZ2xlLWh1ZSBzY2FsZS4gVGhlXG4gICAqIG51bWJlciBvZiBjb2xvcnMgaXMgY29udHJvbGxlZCBieSB0aGUgYG1heExldmVsYCBwcm9wZXJ0eS4gQ29sb3JzIGNhbiBiZVxuICAgKiBzcGVjaWZpZWQgaW4gYW55IHZhbGlkIENTUyBmb3JtYXQuXG4gICAqXG4gICAqIFRoZSBjb2xvcnMgZm9yIGF0IGxlYXN0IG9uZSBzY2hlbWUgbXVzdCBiZSBzZXQuIElmIHVuZGVmaW5lZCwgdGhlIGRlZmF1bHRcbiAgICogdGhlbWUgaXMgdXNlZC4gQnkgZGVmYXVsdCwgdGhlIGNhbGVuZGFyIHdpbGwgc2VsZWN0IHRoZSBjdXJyZW50IHN5c3RlbSBjb2xvclxuICAgKiBzY2hlbWUsIGJ1dCB5b3UgY2FuIGVuZm9yY2UgYSBzcGVjaWZpYyBzY2hlbWUgd2l0aCB0aGUgYGNvbG9yU2NoZW1lYCBwcm9wLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGB0c3hcbiAgICogPEFjdGl2aXR5Q2FsZW5kYXJcbiAgICogICBkYXRhPXtkYXRhfVxuICAgKiAgIHRoZW1lPXt7XG4gICAqICAgICBsaWdodDogWydoc2woMCwgMCUsIDkyJSknLCAnZmlyZWJyaWNrJ10sXG4gICAqICAgICBkYXJrOiBbJyMzMzMnLCAncmdiKDIxNCwgMTYsIDE3NCknXSxcbiAgICogICB9fVxuICAgKiAvPlxuICAgKiBgYGBcbiAgICpcbiAgICovXG4gIHRoZW1lPzogVGhlbWVJbnB1dFxuICAvKipcbiAgICogT3ZlcndyaXRlIHRoZSB0b3RhbCBhY3Rpdml0eSBjb3VudC5cbiAgICovXG4gIHRvdGFsQ291bnQ/OiBudW1iZXJcbiAgLyoqXG4gICAqIEluZGV4IG9mIGRheSB0byBiZSB1c2VkIGFzIHN0YXJ0IG9mIHdlZWsuIDAgcmVwcmVzZW50cyBTdW5kYXkuXG4gICAqL1xuICB3ZWVrU3RhcnQ/OiBEYXlJbmRleFxufVxuXG5leHBvcnQgY29uc3QgQWN0aXZpdHlDYWxlbmRhciA9IGZvcndhcmRSZWY8SFRNTEVsZW1lbnQsIFByb3BzPihcbiAgKFxuICAgIHtcbiAgICAgIGRhdGE6IGFjdGl2aXRpZXMsXG4gICAgICBibG9ja01hcmdpbiA9IDQsXG4gICAgICBibG9ja1JhZGl1cyA9IDIsXG4gICAgICBibG9ja1NpemUgPSAxMixcbiAgICAgIGNvbG9yU2NoZW1lOiBjb2xvclNjaGVtZVByb3AgPSB1bmRlZmluZWQsXG4gICAgICBldmVudEhhbmRsZXJzID0ge30sXG4gICAgICBmb250U2l6ZSA9IDE0LFxuICAgICAgaGlkZUNvbG9yTGVnZW5kID0gZmFsc2UsXG4gICAgICBoaWRlTW9udGhMYWJlbHMgPSBmYWxzZSxcbiAgICAgIGhpZGVUb3RhbENvdW50ID0gZmFsc2UsXG4gICAgICBsYWJlbHM6IGxhYmVsc1Byb3AgPSB1bmRlZmluZWQsXG4gICAgICBtYXhMZXZlbCA9IDQsXG4gICAgICBsb2FkaW5nID0gZmFsc2UsXG4gICAgICByZW5kZXJCbG9jayA9IHVuZGVmaW5lZCxcbiAgICAgIHJlbmRlckNvbG9yTGVnZW5kID0gdW5kZWZpbmVkLFxuICAgICAgc2hvd1dlZWtkYXlMYWJlbHMgPSBmYWxzZSxcbiAgICAgIHN0eWxlOiBzdHlsZVByb3AgPSB7fSxcbiAgICAgIHRoZW1lOiB0aGVtZVByb3AgPSB1bmRlZmluZWQsXG4gICAgICB0b3RhbENvdW50OiB0b3RhbENvdW50UHJvcCA9IHVuZGVmaW5lZCxcbiAgICAgIHdlZWtTdGFydCA9IDAsIC8vIFN1bmRheVxuICAgIH06IFByb3BzLCAvLyBSZXF1aXJlZCBmb3IgcmVhY3QtZG9jZ2VuXG4gICAgcmVmLFxuICApID0+IHtcbiAgICBjb25zdCBbaXNDbGllbnQsIHNldElzQ2xpZW50XSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBzZXRJc0NsaWVudCh0cnVlKVxuICAgIH0sIFtdKVxuXG4gICAgbWF4TGV2ZWwgPSBNYXRoLm1heCgxLCBtYXhMZXZlbClcblxuICAgIGNvbnN0IHRoZW1lID0gY3JlYXRlVGhlbWUodGhlbWVQcm9wLCBtYXhMZXZlbCArIDEpXG4gICAgY29uc3Qgc3lzdGVtQ29sb3JTY2hlbWUgPSB1c2VDb2xvclNjaGVtZSgpXG4gICAgY29uc3QgY29sb3JTY2hlbWUgPSBjb2xvclNjaGVtZVByb3AgPz8gc3lzdGVtQ29sb3JTY2hlbWVcbiAgICBjb25zdCBjb2xvclNjYWxlID0gdGhlbWVbY29sb3JTY2hlbWVdXG5cbiAgICB1c2VMb2FkaW5nQW5pbWF0aW9uKGNvbG9yU2NhbGVbMF0gYXMgc3RyaW5nLCBjb2xvclNjaGVtZSlcbiAgICBjb25zdCB1c2VBbmltYXRpb24gPSAhdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24oKVxuXG4gICAgaWYgKGxvYWRpbmcpIHtcbiAgICAgIGFjdGl2aXRpZXMgPSBnZW5lcmF0ZUVtcHR5RGF0YSgpXG4gICAgfVxuXG4gICAgdmFsaWRhdGVBY3Rpdml0aWVzKGFjdGl2aXRpZXMsIG1heExldmVsKVxuXG4gICAgY29uc3QgZmlyc3RBY3Rpdml0eSA9IGFjdGl2aXRpZXNbMF0gYXMgQWN0aXZpdHlcbiAgICBjb25zdCB5ZWFyID0gZ2V0WWVhcihwYXJzZUlTTyhmaXJzdEFjdGl2aXR5LmRhdGUpKVxuICAgIGNvbnN0IHdlZWtzID0gZ3JvdXBCeVdlZWtzKGFjdGl2aXRpZXMsIHdlZWtTdGFydClcblxuICAgIGNvbnN0IGxhYmVscyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfTEFCRUxTLCBsYWJlbHNQcm9wKVxuICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gaGlkZU1vbnRoTGFiZWxzID8gMCA6IGZvbnRTaXplICsgTEFCRUxfTUFSR0lOXG5cbiAgICBjb25zdCB3ZWVrZGF5TGFiZWxzID0gaW5pdFdlZWtkYXlMYWJlbHMoc2hvd1dlZWtkYXlMYWJlbHMsIHdlZWtTdGFydClcblxuICAgIC8vIE11c3QgYmUgY2FsY3VsYXRlZCBvbiB0aGUgY2xpZW50IG9yIFNTUiBoeWRyYXRpb24gZXJyb3JzIHdpbGwgb2NjdXJcbiAgICAvLyBiZWNhdXNlIHNlcnZlciBhbmQgY2xpZW50IEhUTUwgd291bGQgbm90IG1hdGNoLlxuICAgIGNvbnN0IHdlZWtkYXlMYWJlbE9mZnNldCA9XG4gICAgICBpc0NsaWVudCAmJiB3ZWVrZGF5TGFiZWxzLnNob3VsZFNob3dcbiAgICAgICAgPyBtYXhXZWVrZGF5TGFiZWxXaWR0aChsYWJlbHMud2Vla2RheXMsIHdlZWtkYXlMYWJlbHMsIGZvbnRTaXplKSArIExBQkVMX01BUkdJTlxuICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgZnVuY3Rpb24gZ2V0RGltZW5zaW9ucygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3ZWVrcy5sZW5ndGggKiAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pIC0gYmxvY2tNYXJnaW4sXG4gICAgICAgIGhlaWdodDogbGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogNyAtIGJsb2NrTWFyZ2luLFxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEV2ZW50SGFuZGxlcnMoYWN0aXZpdHk6IEFjdGl2aXR5KTogU1ZHUmVjdEV2ZW50SGFuZGxlciB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBPYmplY3Qua2V5cyhldmVudEhhbmRsZXJzKSBhcyBBcnJheTxrZXlvZiBTVkdSZWN0RXZlbnRIYW5kbGVyPlxuICAgICAgKS5yZWR1Y2U8U1ZHUmVjdEV2ZW50SGFuZGxlcj4oXG4gICAgICAgIChoYW5kbGVycywga2V5KSA9PiAoe1xuICAgICAgICAgIC4uLmhhbmRsZXJzLFxuICAgICAgICAgIFtrZXldOiAoZXZlbnQ6IFJlYWN0RXZlbnQ8U1ZHUmVjdEVsZW1lbnQ+KSA9PiBldmVudEhhbmRsZXJzW2tleV0/LihldmVudCkoYWN0aXZpdHkpLFxuICAgICAgICB9KSxcbiAgICAgICAge30sXG4gICAgICApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyQ2FsZW5kYXIoKSB7XG4gICAgICByZXR1cm4gd2Vla3NcbiAgICAgICAgLm1hcCgod2Vlaywgd2Vla0luZGV4KSA9PlxuICAgICAgICAgIHdlZWsubWFwKChhY3Rpdml0eSwgZGF5SW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmICghYWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbG9hZGluZ0FuaW1hdGlvbiA9XG4gICAgICAgICAgICAgIGxvYWRpbmcgJiYgdXNlQW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYCR7bG9hZGluZ0FuaW1hdGlvbk5hbWV9IDEuNzVzIGVhc2UtaW4tb3V0IGluZmluaXRlYCxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRGVsYXk6IGAke3dlZWtJbmRleCAqIDIwICsgZGF5SW5kZXggKiAyMH1tc2AsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcblxuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSAoXG4gICAgICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICAgICAgey4uLmdldEV2ZW50SGFuZGxlcnMoYWN0aXZpdHkpfVxuICAgICAgICAgICAgICAgIHg9ezB9XG4gICAgICAgICAgICAgICAgeT17bGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogZGF5SW5kZXh9XG4gICAgICAgICAgICAgICAgd2lkdGg9e2Jsb2NrU2l6ZX1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9e2Jsb2NrU2l6ZX1cbiAgICAgICAgICAgICAgICByeD17YmxvY2tSYWRpdXN9XG4gICAgICAgICAgICAgICAgcnk9e2Jsb2NrUmFkaXVzfVxuICAgICAgICAgICAgICAgIGZpbGw9e2NvbG9yU2NhbGVbYWN0aXZpdHkubGV2ZWxdfVxuICAgICAgICAgICAgICAgIGRhdGEtZGF0ZT17YWN0aXZpdHkuZGF0ZX1cbiAgICAgICAgICAgICAgICBkYXRhLWxldmVsPXthY3Rpdml0eS5sZXZlbH1cbiAgICAgICAgICAgICAgICBzdHlsZT17eyAuLi5zdHlsZXMucmVjdChjb2xvclNjaGVtZSksIC4uLmxvYWRpbmdBbmltYXRpb24gfX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPEZyYWdtZW50IGtleT17YWN0aXZpdHkuZGF0ZX0+XG4gICAgICAgICAgICAgICAge3JlbmRlckJsb2NrID8gcmVuZGVyQmxvY2soYmxvY2ssIGFjdGl2aXR5KSA6IGJsb2NrfVxuICAgICAgICAgICAgICA8L0ZyYWdtZW50PlxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pLFxuICAgICAgICApXG4gICAgICAgIC5tYXAoKHdlZWssIHgpID0+IChcbiAgICAgICAgICA8ZyBrZXk9e3h9IHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgkeyhibG9ja1NpemUgKyBibG9ja01hcmdpbikgKiB4fSwgMClgfT5cbiAgICAgICAgICAgIHt3ZWVrfVxuICAgICAgICAgIDwvZz5cbiAgICAgICAgKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJGb290ZXIoKSB7XG4gICAgICBpZiAoaGlkZVRvdGFsQ291bnQgJiYgaGlkZUNvbG9yTGVnZW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvdGFsQ291bnQgPVxuICAgICAgICB0eXBlb2YgdG90YWxDb3VudFByb3AgPT09ICdudW1iZXInXG4gICAgICAgICAgPyB0b3RhbENvdW50UHJvcFxuICAgICAgICAgIDogYWN0aXZpdGllcy5yZWR1Y2UoKHN1bSwgYWN0aXZpdHkpID0+IHN1bSArIGFjdGl2aXR5LmNvdW50LCAwKVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Zm9vdGVyXG4gICAgICAgICAgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ2Zvb3RlcicpfVxuICAgICAgICAgIHN0eWxlPXt7IC4uLnN0eWxlcy5mb290ZXIuY29udGFpbmVyLCBtYXJnaW5MZWZ0OiB3ZWVrZGF5TGFiZWxPZmZzZXQgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHsvKiBQbGFjZWhvbGRlciAqL31cbiAgICAgICAgICB7bG9hZGluZyAmJiA8ZGl2PiZuYnNwOzwvZGl2Pn1cblxuICAgICAgICAgIHshbG9hZGluZyAmJiAhaGlkZVRvdGFsQ291bnQgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2dldENsYXNzTmFtZSgnY291bnQnKX0+XG4gICAgICAgICAgICAgIHtsYWJlbHMudG90YWxDb3VudFxuICAgICAgICAgICAgICAgID8gbGFiZWxzLnRvdGFsQ291bnRcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3t7Y291bnR9fScsIFN0cmluZyh0b3RhbENvdW50KSlcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3t7eWVhcn19JywgU3RyaW5nKHllYXIpKVxuICAgICAgICAgICAgICAgIDogYCR7dG90YWxDb3VudH0gYWN0aXZpdGllcyBpbiAke3llYXJ9YH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG5cbiAgICAgICAgICB7IWxvYWRpbmcgJiYgIWhpZGVDb2xvckxlZ2VuZCAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Z2V0Q2xhc3NOYW1lKCdsZWdlbmQtY29sb3JzJyl9IHN0eWxlPXtzdHlsZXMuZm9vdGVyLmxlZ2VuZH0+XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IG1hcmdpblJpZ2h0OiAnMC40ZW0nIH19PntsYWJlbHMubGVnZW5kLmxlc3N9PC9zcGFuPlxuICAgICAgICAgICAgICB7cmFuZ2UobWF4TGV2ZWwgKyAxKS5tYXAobGV2ZWwgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gKFxuICAgICAgICAgICAgICAgICAgPHN2ZyB3aWR0aD17YmxvY2tTaXplfSBoZWlnaHQ9e2Jsb2NrU2l6ZX0+XG4gICAgICAgICAgICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg9e2Jsb2NrU2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9e2Jsb2NrU2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgICBmaWxsPXtjb2xvclNjYWxlW2xldmVsXX1cbiAgICAgICAgICAgICAgICAgICAgICByeD17YmxvY2tSYWRpdXN9XG4gICAgICAgICAgICAgICAgICAgICAgcnk9e2Jsb2NrUmFkaXVzfVxuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXtzdHlsZXMucmVjdChjb2xvclNjaGVtZSl9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgPEZyYWdtZW50IGtleT17bGV2ZWx9PlxuICAgICAgICAgICAgICAgICAgICB7cmVuZGVyQ29sb3JMZWdlbmQgPyByZW5kZXJDb2xvckxlZ2VuZChibG9jaywgbGV2ZWwpIDogYmxvY2t9XG4gICAgICAgICAgICAgICAgICA8L0ZyYWdtZW50PlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IG1hcmdpbkxlZnQ6ICcwLjRlbScgfX0+e2xhYmVscy5sZWdlbmQubW9yZX08L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Zvb3Rlcj5cbiAgICAgIClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJXZWVrZGF5TGFiZWxzKCkge1xuICAgICAgaWYgKCF3ZWVrZGF5TGFiZWxzLnNob3VsZFNob3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGcgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ2xlZ2VuZC13ZWVrZGF5Jyl9PlxuICAgICAgICAgIHtyYW5nZSg3KS5tYXAoaW5kZXggPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF5SW5kZXggPSAoKGluZGV4ICsgd2Vla1N0YXJ0KSAlIDcpIGFzIERheUluZGV4XG5cbiAgICAgICAgICAgIGlmICghd2Vla2RheUxhYmVscy5ieURheUluZGV4KGRheUluZGV4KSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8dGV4dFxuICAgICAgICAgICAgICAgIHg9ey1MQUJFTF9NQVJHSU59XG4gICAgICAgICAgICAgICAgeT17bGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogaW5kZXggKyBibG9ja1NpemUgLyAyfVxuICAgICAgICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU9XCJjZW50cmFsXCJcbiAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwiZW5kXCJcbiAgICAgICAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge2xhYmVscy53ZWVrZGF5c1tkYXlJbmRleF19XG4gICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KX1cbiAgICAgICAgPC9nPlxuICAgICAgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlck1vbnRoTGFiZWxzKCkge1xuICAgICAgaWYgKGhpZGVNb250aExhYmVscykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8ZyBjbGFzc05hbWU9e2dldENsYXNzTmFtZSgnbGVnZW5kLW1vbnRoJyl9PlxuICAgICAgICAgIHtnZXRNb250aExhYmVscyh3ZWVrcywgbGFiZWxzLm1vbnRocykubWFwKCh7IGxhYmVsLCB3ZWVrSW5kZXggfSkgPT4gKFxuICAgICAgICAgICAgPHRleHRcbiAgICAgICAgICAgICAgeD17KGJsb2NrU2l6ZSArIGJsb2NrTWFyZ2luKSAqIHdlZWtJbmRleH1cbiAgICAgICAgICAgICAgeT17MH1cbiAgICAgICAgICAgICAgZG9taW5hbnRCYXNlbGluZT1cImhhbmdpbmdcIlxuICAgICAgICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAga2V5PXt3ZWVrSW5kZXh9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9nPlxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0RGltZW5zaW9ucygpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGFydGljbGVcbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIGNsYXNzTmFtZT17TkFNRVNQQUNFfVxuICAgICAgICBzdHlsZT17eyAuLi5zdHlsZVByb3AsIC4uLnN0eWxlcy5jb250YWluZXIoZm9udFNpemUpIH19XG4gICAgICA+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ3Njcm9sbC1jb250YWluZXInKX0gc3R5bGU9e3N0eWxlcy5zY3JvbGxDb250YWluZXIoZm9udFNpemUpfT5cbiAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgIHZpZXdCb3g9e2AwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Z2V0Q2xhc3NOYW1lKCdjYWxlbmRhcicpfVxuICAgICAgICAgICAgc3R5bGU9e3sgLi4uc3R5bGVzLmNhbGVuZGFyLCBtYXJnaW5MZWZ0OiB3ZWVrZGF5TGFiZWxPZmZzZXQgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7IWxvYWRpbmcgJiYgcmVuZGVyV2Vla2RheUxhYmVscygpfVxuICAgICAgICAgICAgeyFsb2FkaW5nICYmIHJlbmRlck1vbnRoTGFiZWxzKCl9XG4gICAgICAgICAgICB7cmVuZGVyQ2FsZW5kYXIoKX1cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIHtyZW5kZXJGb290ZXIoKX1cbiAgICAgIDwvYXJ0aWNsZT5cbiAgICApXG4gIH0sXG4pXG5cbkFjdGl2aXR5Q2FsZW5kYXIuZGlzcGxheU5hbWUgPSAnQWN0aXZpdHlDYWxlbmRhcidcblxuZXhwb3J0IGNvbnN0IFNrZWxldG9uID0gKHByb3BzOiBPbWl0PFByb3BzLCAnZGF0YSc+KSA9PiA8QWN0aXZpdHlDYWxlbmRhciBkYXRhPXtbXX0gey4uLnByb3BzfSAvPlxuIl0sIm5hbWVzIjpbIk5BTUVTUEFDRSIsIkxBQkVMX01BUkdJTiIsIkRFRkFVTFRfTU9OVEhfTEFCRUxTIiwiREVGQVVMVF9MQUJFTFMiLCJtb250aHMiLCJ3ZWVrZGF5cyIsInRvdGFsQ291bnQiLCJsZWdlbmQiLCJsZXNzIiwibW9yZSIsInVzZUNvbG9yU2NoZW1lIiwiY29sb3JTY2hlbWUiLCJzZXRDb2xvclNjaGVtZSIsInVzZVN0YXRlIiwib25DaGFuZ2UiLCJldmVudCIsIm1hdGNoZXMiLCJ1c2VFZmZlY3QiLCJtZWRpYVF1ZXJ5Iiwid2luZG93IiwibWF0Y2hNZWRpYSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibG9hZGluZ0FuaW1hdGlvbk5hbWUiLCJ1c2VMb2FkaW5nQW5pbWF0aW9uIiwiemVyb0NvbG9yIiwiY29sb3JMb2FkaW5nIiwiY29sb3JBY3RpdmUiLCJzdHlsZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwicXVlcnkiLCJ1c2VQcmVmZXJzUmVkdWNlZE1vdGlvbiIsInByZWZlcnNSZWR1Y2VkTW90aW9uIiwic2V0UHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJ2YWxpZGF0ZUFjdGl2aXRpZXMiLCJhY3Rpdml0aWVzIiwibWF4TGV2ZWwiLCJsZW5ndGgiLCJFcnJvciIsImRhdGUiLCJsZXZlbCIsImNvdW50IiwiaXNWYWxpZCIsInBhcnNlSVNPIiwiUmFuZ2VFcnJvciIsImdyb3VwQnlXZWVrcyIsIndlZWtTdGFydCIsIm5vcm1hbGl6ZWRBY3Rpdml0aWVzIiwiZmlsbEhvbGVzIiwiZmlyc3RBY3Rpdml0eSIsImZpcnN0RGF0ZSIsImZpcnN0Q2FsZW5kYXJEYXRlIiwiZ2V0RGF5Iiwic3ViV2Vla3MiLCJuZXh0RGF5IiwicGFkZGVkQWN0aXZpdGllcyIsIkFycmF5IiwiZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzIiwiZmlsbCIsInVuZGVmaW5lZCIsIm51bWJlck9mV2Vla3MiLCJNYXRoIiwiY2VpbCIsInJhbmdlIiwibWFwIiwid2Vla0luZGV4Iiwic2xpY2UiLCJjYWxlbmRhciIsIk1hcCIsImEiLCJsYXN0QWN0aXZpdHkiLCJlYWNoRGF5T2ZJbnRlcnZhbCIsInN0YXJ0IiwiZW5kIiwiZGF5IiwiZm9ybWF0SVNPIiwicmVwcmVzZW50YXRpb24iLCJoYXMiLCJnZXQiLCJnZXRDbGFzc05hbWUiLCJuYW1lIiwiZ2VuZXJhdGVFbXB0eURhdGEiLCJ5ZWFyIiwiRGF0ZSIsImdldEZ1bGxZZWFyIiwiZGF5cyIsIm4iLCJrZXlzIiwiZ2V0TW9udGhMYWJlbHMiLCJ3ZWVrcyIsIm1vbnRoTmFtZXMiLCJyZWR1Y2UiLCJsYWJlbHMiLCJ3ZWVrIiwiZmluZCIsImFjdGl2aXR5IiwibW9udGgiLCJnZXRNb250aCIsIm1vbnRoTmFtZSIsInRvTG9jYWxlU3RyaW5nIiwicHJldkxhYmVsIiwibGFiZWwiLCJmaWx0ZXIiLCJpbmRleCIsIm1pbldlZWtzIiwibWF4V2Vla2RheUxhYmVsV2lkdGgiLCJzaG93V2Vla2RheUxhYmVsIiwiZm9udFNpemUiLCJtYXhXaWR0aCIsImJ5RGF5SW5kZXgiLCJtYXgiLCJjYWxjVGV4dERpbWVuc2lvbnMiLCJ3aWR0aCIsInRleHQiLCJoZWlnaHQiLCJuYW1lc3BhY2UiLCJzdmciLCJjcmVhdGVFbGVtZW50TlMiLCJwb3NpdGlvbiIsInZpc2liaWxpdHkiLCJmb250RmFtaWx5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImJvZHkiLCJ0ZXh0Tm9kZSIsInRleHRDb250ZW50IiwiYm91bmRpbmdCb3giLCJnZXRCQm94IiwiaW5pdFdlZWtkYXlMYWJlbHMiLCJpbnB1dCIsInNob3VsZFNob3ciLCJpbmRleGVkIiwiZGF5TmFtZVRvSW5kZXgiLCJ0b0xvd2VyQ2FzZSIsInN1biIsIm1vbiIsInR1ZSIsIndlZCIsInRodSIsImZyaSIsInNhdCIsImNyZWF0ZVRoZW1lIiwic3RlcHMiLCJkZWZhdWx0VGhlbWUiLCJjcmVhdGVEZWZhdWx0VGhlbWUiLCJ2YWxpZGF0ZVRoZW1lSW5wdXQiLCJsaWdodCIsImRhcmsiLCJpc1BhaXIiLCJjYWxjQ29sb3JTY2FsZSIsIm1heExldmVsSGludCIsImMiLCJDU1MiLCJzdXBwb3J0cyIsImkiLCJwb3MiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsInZhbCIsInN0eWxlcyIsImNvbnRhaW5lciIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiZ2FwIiwic2Nyb2xsQ29udGFpbmVyIiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwicGFkZGluZ1RvcCIsIm92ZXJmbG93IiwicmVjdCIsInN0cm9rZSIsImZvb3RlciIsImZsZXhXcmFwIiwid2hpdGVTcGFjZSIsIm1hcmdpbkxlZnQiLCJhbGlnbkl0ZW1zIiwiQWN0aXZpdHlDYWxlbmRhciIsImZvcndhcmRSZWYiLCJkYXRhIiwiYmxvY2tNYXJnaW4iLCJibG9ja1JhZGl1cyIsImJsb2NrU2l6ZSIsImNvbG9yU2NoZW1lUHJvcCIsImV2ZW50SGFuZGxlcnMiLCJoaWRlQ29sb3JMZWdlbmQiLCJoaWRlTW9udGhMYWJlbHMiLCJoaWRlVG90YWxDb3VudCIsImxhYmVsc1Byb3AiLCJsb2FkaW5nIiwicmVuZGVyQmxvY2siLCJyZW5kZXJDb2xvckxlZ2VuZCIsInNob3dXZWVrZGF5TGFiZWxzIiwic3R5bGVQcm9wIiwidGhlbWUiLCJ0aGVtZVByb3AiLCJ0b3RhbENvdW50UHJvcCIsInJlZiIsImlzQ2xpZW50Iiwic2V0SXNDbGllbnQiLCJzeXN0ZW1Db2xvclNjaGVtZSIsImNvbG9yU2NhbGUiLCJ1c2VBbmltYXRpb24iLCJnZXRZZWFyIiwiT2JqZWN0IiwiYXNzaWduIiwibGFiZWxIZWlnaHQiLCJ3ZWVrZGF5TGFiZWxzIiwid2Vla2RheUxhYmVsT2Zmc2V0IiwiZ2V0RGltZW5zaW9ucyIsImdldEV2ZW50SGFuZGxlcnMiLCJoYW5kbGVycyIsImtleSIsInJlbmRlckNhbGVuZGFyIiwiZGF5SW5kZXgiLCJsb2FkaW5nQW5pbWF0aW9uIiwiYW5pbWF0aW9uIiwiYW5pbWF0aW9uRGVsYXkiLCJibG9jayIsIl9qc3giLCJ4IiwieSIsInJ4IiwicnkiLCJGcmFnbWVudCIsImNoaWxkcmVuIiwidHJhbnNmb3JtIiwicmVuZGVyRm9vdGVyIiwic3VtIiwiX2pzeHMiLCJjbGFzc05hbWUiLCJyZXBsYWNlIiwiU3RyaW5nIiwibWFyZ2luUmlnaHQiLCJyZW5kZXJXZWVrZGF5TGFiZWxzIiwiZG9taW5hbnRCYXNlbGluZSIsInRleHRBbmNob3IiLCJyZW5kZXJNb250aExhYmVscyIsInZpZXdCb3giLCJkaXNwbGF5TmFtZSIsIlNrZWxldG9uIiwicHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-activity-calendar/build/index.js\n");

/***/ })

};
;